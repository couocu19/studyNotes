# Redis系统学习(二)

## Redis持久化流程

1. 客户端向服务端发送写操作。**（数据在客户端的内存中）**
2. 数据库服务端收到客户端写请求发来的数据。**（数据在服务端的内存中）**
3. 服务端调用write这个系统调用，将数据往磁盘中写。**（数据在系统内存的缓冲区中）**
4. 操作系统将缓冲区中的数据转移到磁盘控制器上。**（数据在磁盘缓存中）**
5. 磁盘控制器将数据写到磁盘的物理介质中。**（数据真正落实到磁盘中）**

- ### 遇到的问题：

   上述过程是在理想状态下的过程，但是大多数情况下，机器会有各种各样的故障，这里划分了两种情况。

  1.  Redis数据库发生故障，只要上述三步完成，后面的两步由操作系统替我们完成。
  2. 操作系统发生故障，必须上面5步全部完成。



## Redis持久化的两种方式

​    Redis如何实现上述5个保存到磁盘的步骤？

- ### RDB(Redis DataBase)

  #### 概念：

  ​    将数据以快照形式保存在磁盘上。快照，可以理解为把即刻的数据拍成一张照片保存下来。

  ​    RDB持久化是指在指定的时间间隔内将数据集快照写入磁盘。也是**默认的持久化方式，就是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。.**

  ​    ps: 在redis.conf配置文件中含有RDB和AOF两种持久化数据机制的各种配置。

  ​    对于RDB的持久化方式，提供了三种机制：**save，bgsave，自动化。**

  - **save触发方式**

    该命令会阻塞当前Redis服务器，即执行save命令期间不能执行其他命令，此时其他客户端向redis服务器发出的请求都会被阻塞，必须当RDB全部执行完毕之后才可以处理其他请求。

    执行完成的时候如果存在老的RDB（二进制）文件，会用新的文件代替旧的文件。但是我们的客户端都是几万或者几十万的请求，这种方式显然不可取。

  - **bgsave触发方式**

    该命令会异步的处理bgsave命令以及其他客户端的命令，在开始进行bgsave命令时，**redis进程执行fork操作创建一个子进程**，子进程负责执行RDB的持久化过程，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上Redis内部所有的RDB操作都是采用bgsave命令。

  - **自动化触发方式**

  #### 优势：

  1. RDB文件紧凑，全量备份，非常适合用于备份和灾难恢复。
  2. 在生成RDB文件的时候，主进程会fork一个子进程来执行，主进程不需要进行任何磁盘的io操作。
  3. 在恢复大量数据集的时候，速度比AOF快。

  #### 劣势：

    RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。

  

- ### AOF(Append Only File)

  ####  概念：

  ​     全量备份总是耗时的，这里有一种更加高效的方式--AOF。

  ​     **工作机制：redis会将收到的每一个写命令都通过write函数追加到文件中。通俗的理解就是日志记录。**

  ####  持久化原理：

  ​    ![img](https://pics3.baidu.com/feed/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg?token=394597ccd73bd15778c518b5c5be6998&s=2D62E7169D305F8A847546E20200B036)

  ​    

  ​    每有一个写命令传过来，就将其直接保存在AOF文件中。

  ####  文件重写原理：

  ​    AOF会带来的一个问题--持久化文件会越来越大。

     为了压缩持久化文件，redis提供了bgwriteaof命令--将内存中的数据以命令的方式保存在临时文件中，同时会fork出一条新的进程将文件重写。

    ![img](https://pics7.baidu.com/feed/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg?token=86eda46b8bcd54a7a0e7d8a37d87bee8&s=EDB2A4579D317B824660D4DF0200E036)

  ​      

  #### AOF的三种触发机制：

  1. 每修改同步always：

     ​    **同步持久化，每次发生数据变更会立即记录到磁盘，性能比较差但是数据的完整性比较好。**

  2. 每秒同步everysec：

     ​    **异步操作，每秒记录，如果一秒内宕机，有数据丢失。**

  3. 不同no：

        **从不同步**

  ​    ![img](https://pics5.baidu.com/feed/b17eca8065380cd7df69859ba056a5325982816c.jpeg?token=a060f459d81c409c3d6c7208d2118888&s=AF4AA5574ED85CC841D04BE60300A036)

  

#### 优点：

1.  可以更好地保护数据不被丢失，一般AOF会每隔一秒，通过一个后台线程执行一次fsync操作，最多丢失一秒的数据。
2. AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。
3. AOF日志文件即使过大的时候，引起后台的重写，也不会影响客户端的读写操作。
4. AOF日志文件的命令通过非常可读的方式记录，这个特此非常适合做灾难性的误删除的紧急恢复。若某人不小心用flushall命令清空了所有数据，只要后台的rewrite还没有发生，就可以拷贝AOF文件，将最后一条flushall命令删掉，然后再将AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。

#### 缺点：

1. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。

2. AOF开启之后，支持的写QPS比RDB的QPS更低，因为AOF一般会设置成每秒进行一次fsync，当然，一秒进行一次fsync，效率还是很高的。

     ps：QPS（Query Per Second）：每秒查询率

3. 在通过AOF的日志记录恢复数据时，有时候不能恢复出一模一样的数据来。

#### RDB和AOF的选择问题：

   ![img](https://pics5.baidu.com/feed/8326cffc1e178a82c532308ef2117b8ba977e8ae.jpeg?token=fea28817e45f0e091b5be3854d856fbb&s=BD48B55F1C784C095E61DCEB0300D036)