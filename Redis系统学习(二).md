# Redis系统学习(二)

## Redis持久化流程

1. 客户端向服务端发送写操作。**（数据在客户端的内存中）**
2. 数据库服务端收到客户端写请求发来的数据。**（数据在服务端的内存中）**
3. 服务端调用write这个系统调用，将数据往磁盘中写。**（数据在系统内存的缓冲区中）**
4. 操作系统将缓冲区中的数据转移到磁盘控制器上。**（数据在磁盘缓存中）**
5. 磁盘控制器将数据写到磁盘的物理介质中。**（数据真正落实到磁盘中）**

- ### 遇到的问题：

   上述过程是在理想状态下的过程，但是大多数情况下，机器会有各种各样的故障，这里划分了两种情况。

  1.  Redis数据库发生故障，只要上述三步完成，后面的两步由操作系统替我们完成。
  2. 操作系统发生故障，必须上面5步全部完成。



## Redis持久化的两种方式

​    Redis如何实现上述5个保存到磁盘的步骤？

- ### RDB(Redis DataBase)

  #### 概念：

  ​    将数据以快照形式保存在磁盘上。快照，可以理解为把即刻的数据拍成一张照片保存下来。

  ​    RDB持久化是指在指定的时间间隔内将数据集快照写入磁盘。也是**默认的持久化方式，就是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。.**

  ​    ps: 在redis.conf配置文件中含有RDB和AOF两种持久化数据机制的各种配置。

  ​    对于RDB的持久化方式，提供了三种机制：**save，bgsave，自动化。**

  - **save触发方式**

    该命令会阻塞当前Redis服务器，即执行save命令期间不能执行其他命令，此时其他客户端向redis服务器发出的请求都会被阻塞，必须当RDB全部执行完毕之后才可以处理其他请求。

    执行完成的时候如果存在老的RDB（二进制）文件，会用新的文件代替旧的文件。但是我们的客户端都是几万或者几十万的请求，这种方式显然不可取。

  - **bgsave触发方式**

    该命令会异步的处理bgsave命令以及其他客户端的命令，在开始进行bgsave命令时，**redis进程执行fork操作创建一个子进程**，子进程负责执行RDB的持久化过程，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上Redis内部所有的RDB操作都是采用bgsave命令。

  - **自动化触发方式**

  #### 优势：

  1. RDB文件紧凑，全量备份，非常适合用于备份和灾难恢复。
  2. 在生成RDB文件的时候，主进程会fork一个子进程来执行，主进程不需要进行任何磁盘的io操作。
  3. 在恢复大量数据集的时候，速度比AOF快。

  #### 劣势：

    RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子**进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。**

  

- ### AOF(Append Only File)

  ####  概念：

  ​     全量备份总是耗时的，这里有一种更加高效的方式--AOF。

  ​     **工作机制：redis会将收到的每一个写命令都通过write函数追加到文件中。通俗的理解就是日志记录。**

  ####  持久化原理：

  ​    ![img](https://pics3.baidu.com/feed/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg?token=394597ccd73bd15778c518b5c5be6998&s=2D62E7169D305F8A847546E20200B036)

  ​    

  ​    每有一个写命令传过来，就将其直接保存在AOF文件中。

  ####  文件重写原理：

  ​    AOF会带来的一个问题--持久化文件会越来越大。

     **为了压缩持久化文件**，redis提供了bgwriteaof命令--将内存中的数据以命令的方式保存在临时文件中，同时会fork出一条新的进程将文件重写。

    ![img](https://pics7.baidu.com/feed/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg?token=86eda46b8bcd54a7a0e7d8a37d87bee8&s=EDB2A4579D317B824660D4DF0200E036)

  ​      

  #### AOF的三种触发机制：

  1. 每修改同步always：

     ​    **同步持久化，每次发生数据变更会立即记录到磁盘，性能比较差但是数据的完整性比较好。**

  2. 每秒同步everysec：

     ​    **异步操作，每秒记录，如果一秒内宕机，有数据丢失。**

  3. 不同no：

        **从不同步**

  ​    ![img](https://pics5.baidu.com/feed/b17eca8065380cd7df69859ba056a5325982816c.jpeg?token=a060f459d81c409c3d6c7208d2118888&s=AF4AA5574ED85CC841D04BE60300A036)

  

#### 优点：

1.  可以更好地保护数据不被丢失，一般AOF会每隔一秒，通过一个后台线程执行一次fsync操作，最多丢失一秒的数据。
2. AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。
3. AOF日志文件即使过大的时候，引起后台的重写，也不会影响客户端的读写操作。
4. AOF日志文件的命令通过非常可读的方式记录，这个特此非常适合做灾难性的误删除的紧急恢复。若某人不小心用flushall命令清空了所有数据，只要后台的rewrite还没有发生，就可以拷贝AOF文件，将最后一条flushall命令删掉，然后再将AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。

#### 缺点：

1. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。

2. AOF开启之后，支持的写QPS比RDB的QPS更低，因为AOF一般会设置成每秒进行一次fsync，当然，一秒进行一次fsync，效率还是很高的。

     ps：QPS（Query Per Second）：每秒查询率

3. 在通过AOF的日志记录恢复数据时，有时候不能恢复出一模一样的数据来。

#### RDB和AOF的选择问题：

   ![img](https://pics5.baidu.com/feed/8326cffc1e178a82c532308ef2117b8ba977e8ae.jpeg?token=fea28817e45f0e091b5be3854d856fbb&s=BD48B55F1C784C095E61DCEB0300D036)





## Redis：过期键删除策略

- ### 定时删除：

     在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即删除该键。

- ### 定期删除：

     每隔一段时间，程序就会对数据库进行一次检查，删除里面的过期键。至于要删除多少个键，以及要检查多少个数据库，根据算法而定。

- ### 惰性删除：

     放任键不管，但是每次获取键的时候就会判断当前键是否过期，如果检测到键已经过期，就删除该键。

  注意，上述三种处理方式，前两种为主动删除，第三种为被动删除策略。

  

  ### 1.定时删除

  ​       **优点：**定时删除策略对内存是最友好的，通过设置过期时间及时的删除过期键，能够保证无用的键及时的被删除。                                                                                                                                                                                                                                                                                                                                                                                  

  ​       **缺点：**对cpu时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分时间。

  ​                   因为设置定时器需要使用Redis服务器的时间事件，底层实现用到的是无序列表，处理的时间复杂度为O(N),这样并不能高效的处理。

  ### 2.惰性删除

  ​       优点：对cpu时间来说是最友好的：程序只会在取出键的情况下才会对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下才进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何时间。

  ​       缺点：对内存来说是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库，只要这个过期键不被删除，它占用的内存就不会删除。

  ### 3.定期删除

  定期删除是前两种策略的一种整合和折中：

  - **对cpu的好处：**定期删除策略每隔一段时间来检查并删除过期键，并通过限制删除过期键的时间和频率来减少删除操作对cpu时间的影响。

  - **对内存的好处**：通过定期删除键，有效的减少了因为过期键而带来的内存浪费。

  - 难点：怎样确定删除操作执行的时长和频率：

    - 如果操作执行的太频繁，定期删除策略会退化成定时删除策略，以至于CPU时间过多的消耗在删除过期键上面。
    - 如果删除操作执行的太少，或者执行的时间过短，定期删除策略又会和惰性删除删除策略一样，出现浪费内存的情况。

    

    

    

    ## Redis的过期键处理策略

    redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种策略，服务器何以很好的在合理使用cpu和避免浪费内存之间取得一个平衡。

    ### 1.惰性删除策略的实现

    过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库额的命令在执行之前都会调用expireIfNeeded函数对输入键检查。

    - 如果已经过期，eiN函数将输入键从函数中删除；
    - 如果未过期，那么eiN函数不操作

    ### 2.定期删除策略的实现

    过期键的定期删除有redis.c/activeExpireCycle函数实现，每当redis服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expire字典中随机检查一部分键的过期时间，并删除其中的过期键。

    

    activeExpireCycle函数的工作过程：

    - 函数每次执行时，会从数据库中取出一定量的随机键进行检查，检查数据库中的过期键并将其删除；
    - 在redis中有一个全局变量current_db,用于记录activeExpireCycle函数删除的进度，等下一次检查时，会根据进度继续检查删除。
    - 通过上述的过程，redis中的数据库将被全部遍历完，即其中的过期键将全部被删除，这时会将current.db变量的值恢复为0，然后开始新一轮的检查工作。

    ## AOF，RDB的复制功能对过期键的处理

    ### 1.生成RDB文件

      在执行save或者bgsave命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中。

    ### 2.载入RDB文件

      在启动redis服务器时，如果启动了RDB功能，**服务器会对RDB文件进行载入：**

    - 如果服务器以**主服务器**模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键会被删除，而过期键则被忽略，所以过期键对载入RDB文件的主服务器不会产生影响。

    - 如果服务器以**从服务器**模式进行，那么在载入RDB文件时，文件中保存的键，不论是否过期都会被载入到数据库中。

      但是，主从服务器在进行数据同步的时候，从服务器的数据就会被清空，所以，一般来说，过期键在载入RDB文件的从服务器也不会造成影响。

    

    ------

    

    ### 3.AOF文件的写入

    当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但是还没有被惰性删除或者定期删除，AOF不会因为这个键过期而产生任何影响。

    当过期键被惰性删除或者被定期删除，程序会向AOF文件追加一个DEL命令，显示的记录该键已经被删除。

    ### 4.AOF文件重写

    该过程和生成RDB文件的过程类似，在执行重写时，会检查该键是否过期，如果已经过期，该键将不会被保存到重写的AOF文件中。

    ### 5.复制

    当服务器运行在复制模下时，从服务器的过期键删除动作由主服务器控制；

    - 主服务器在删除一个过期键之后，会显示的向所有从服务器发送一条DEL指令。命令从服务器删除该过期键；
    - 从服务器即使碰到了过期键，也不会删除该键，而是继续处理未过期键一样处理过期键；
    - 从服务器只有在收到了主服务器发来的DEL命令之后，才会删除过期建。

    **为什么要由主服务器来控制过期键的删除？**

      由主服务器同一控制从服务器对过期键的删除，可以保证主从服务器之间数据的一致性。

    

    

    

    

    

    

    

  