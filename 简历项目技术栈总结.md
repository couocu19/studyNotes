# 简历项目技术栈总结

## poet

- ### SpringSecurity+Jwt实现登录功能

  ​      整合SS框架和Jwt实现登录的过程，具体而言是通过用户的用户名和密码，通过SS中的**usernamePasswordAuthenticationFilter**进行认证，内部使用了Au。。Manager类来实现用户身份的认证，基于这个类的认证，需要自己实现两个类，分别是UserDetailService以及UserDetail接口，在UDS类中需要实现loadUserByUserName(String username)这个方法，顾名思义，即根据用户名从数据库中获取到用户的信息，并用户信息封装到UserDetail中，此时就可以将客户端传来的用户的password将UserDetail中的password进行比对，如果信息一致则说明用户的信息认证成功。

  ​     认证成功之后，就可以使用整合的JwtTokenUtil工具类生成一个token，也就是令牌，令牌中就包含了**用户的用户名，令牌创建的时间，加密算法**等信息，将token返回给客户端。这时就等于认证成功以及生成了JWT令牌。

  ​     当客户端再次访问服务端资源时，会在http请求中携带JWT，这时会首先经过一个JwtAuthenticationTokenFilter检查请求中是否带有token并提取其中的用户信息，之后会调用之前实现的UserdetailService并加载UserDetail，返回UserDetail并根据其中的用户信息校验Jwt令牌的合法性，返回Jwt令牌是否合法。

  ​     如果检测到Jwt合法，根据Userdetails构建UserName……Token表示认证通过。

  ​    这时相当于通过了用户名密码认证过滤器的认证，表示认证通过。**usernamePasswordAuthenticationFilter**发现user……token已经通过了认证，就不会拦截该请求。

  ​    返回请求所对应的响应结果。

  

- ### SpringSecurity+RABC实现用户角色权限信息管理

  ​     因为考虑到项目中不同权限的用户会对应不同的功能/服务，换句话说，并不是所有接口功能都是可以供所有用户使用的。

  ​     首先，设计该功能的主要目的就是模拟一下应对不同角色，身份的用户怎样处理接口的使用权限。

  ​     比如管理员用户登录之后可以查看所有注册用户的信息，普通用户不授予该功能。或者普通级别用户和会员级别，不同等级用户会有部分不同的等级服务。**简单来说就是，有部分接口功能是只允许一部分类型的用户来使用的**，本项目较为简单，只分了管理员和普通类型两种用户。

  ​     所以在项目中加入了RABC角色权限信息管理。

  ​     即一个用户会有自己对应的角色，自己的角色会对应一系列自己的权限，再本项目中一个用户只对应一个角色，主要在管理员和普通用户之间做了权限的区分管理。

  ​     对于RABC模型的实现，主要体现在user，role，role_menu,menu表的建立上，通过一对多，多对多的关系数据库之间的id对应关系将其关联起来。

  ​** 在持久层表的建立基础之上，在UserDetailService类中通过username获取用户的基本信息和角色权限列表（这里需要使用多表联查来实现。**

  ​     然后就需要在SecurityConfig配置文件中进行配置，即每有一个用户请求某一个功能首先通过过滤器拦截，判断当前请求的服务在不在当前用户的权限列表中，如果在列表中，则可以继续访问，否则拒绝访问。

  

  ![img](https://img-blog.csdn.net/20161226141519671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9fY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  ### 

### jwt登录原理图：

初次访问：

![img](https://img2018.cnblogs.com/blog/1843944/201911/1843944-20191112103418437-2034979296.jpg) 

再次访问：

![img](https://img2018.cnblogs.com/blog/1843944/201911/1843944-20191112103432267-232405862.jpg) 

token过期后

![img](https://img2018.cnblogs.com/blog/1843944/201911/1843944-20191112103441192-801731998.jpg) 





## 微社交动态墙

### 2022.3.19更新

**项目难点：**

```
项目整体没有很难的技术栈，难度主要在底层数据库表的设计和一些接口功能的设计。
数据库：
   项目一共设计了6张表，表与表之间的关联性极强，用户，动态，评论，回复，点赞都存在一对多或者多对多的关系。所以在外键，索引上的设计花了功夫。
   
接口功能：
   逻辑上比较复杂的接口是点赞/取消赞的接口设计。
   处理步骤比较多的功能是查看用户主页功能，关注/取关用户功能，查看评论/回复功能。
   eg:查看用户主页相当于是一个很综合的功能，涉及到获取用户个人信息，展示用户的所有动态列表，其中每条动态又涉及到展示评论列表，评论下有回复列表……首先需要三表左外连接联查，再者需要对返回给前端的数据进行处理vo，最后封装成完整的信息list传给前端。
     
```



### SpringSecurity rbac 原理回忆

```
@PreAuthorize("hasAnyAuthority('admin')")

注解原理剖析：
注解中的has......会进入hasAnyAuthority()方法，最终调用getAuthoritySet()方法，也就是调取某个角色对应的用户所拥有的权限列表。而getAuthoritySet() 方法则调用了getAuthorities() 。
这个权限Set就是由getAuthorities()返回的Collection转换而来的。
getAuthorities()这个方法需要我们自己去复写。
```


### 2022 3.1复习

可能遇到的面试问题：

#### 介绍一下你的项目：

```
介绍方向：编写初衷/主要负责任务/项目用到的技术栈/项目的亮点
编写初衷：
    首先这个项目是我和我们实验室学习前端的同学共同编写的，我们当时首先是就编写app的主题进行了一个讨论，在讨论中我们一致想要写一个和我们生活密切相关的，我们很熟悉的应用的app，然后就想到了我们每天都会网上冲浪，而最常用的就是微博，朋友圈，各大论坛。所以这个app就是一个供我们社交用的网络平台。
负责任务：
    我负责后台开发的工作，主要就包括设计表，分析应用所需要的主要需求，以及设计接口的工作。然后项目的主要功能就是...........
技术栈：
    。。。。。。。
项目的亮点和难点：
   1.用户权限的区分 2.jwt登录制度 3.一些接口功能的设计比较巧妙
   4.redis查询缓存提高效率
  
```

### 项目的主要功能？

```
项目的功能可以从用户信息管理模块，用户互动模块，动态管理模块来展开讲。
1.用户信息管理模块：
 用户注册，登录，编辑并修改个人信息，用户权限的区分，管理员用户可以管理所有普通用户，另外还有用户升级制度的设计
 
2.用户互动模块：
 用户之间可以进行互相关注，取消关注，点赞，评论的互动。
 
3.动态管理模块：
 用户可以发表/删除/评论自己的动态，也会生成用户的个人主页信息。同时，也设计了动态推荐的功能。
```



#### 用户升级制的功能是怎么设计的：

```
所谓升级就是当一个用户满足某些条件时就可以实行升级。
升级思路：
首先，用户升级时根据用户的活跃天数来决定的，在设计该接口时设计了用户活跃天数的奖励制度。
而用户活跃天数的奖励制度来源于三个方面，一是用户某次登录的在线时长；；；；；
；lda'f's，二是用户发表的动态数量，三是检测用户连续登录的天数。
对于用户某次登录的在线时长，如果少于半个小时，则不增加活跃值，如果时0.5~2小时，则增加0.5活跃值，如果当天是你大于2小时，就增加一个活跃值。
对于发表动态数量，每日少于三条不增加，3-5增加0.1，大于5条增加0.2.
对于连续登录，大于三天就增加0.5，大于等于5天就增加1，以此类推。
实现方法：
后端上，会在用户user表中设计等级，动态数量，而对于连续登录字段和某天连续在线时长，会由前端去监听并定时向后端请求，后端需要对用户的等级等字段进行一个更新。
```

### 动态推荐

```
热门动态其实主要从两个方面去衡量，点赞数，评论数，浏览数。
其实就是每次刷新时，请求一次推荐接口，并在每次请求时从这三个维度去进行一个排序，排序时，我选择了在dao层，也就是mysql中进行了排序，排序的顺序是点赞数，浏览数，评论数倒叙排列，然后返回一个list到service层。

mysql处理排序时的优化：（磁盘中排序）
要进行排序的这三个字段是需要查询的字段，那么就可以在这三个字段设置联合索引，这样在执行orderby的时候，可以根据mysql中的最左匹配原则来进行排序，实现高效的查询排序。

Java处理排序：（将list返回到内存中，在内存中实现排序） 最底层应该使用的是快排
首先对需要排序的字段封装一个类，并实现接口Comparator接口
		Collections.sort(stus, new Comparator<Student>() {
			@Override
			public int compare(Student s1, Student s2) {
				// 升序
				//return s1.getAge()-s2.getAge();
				return s1.getAge().compareTo(s2.getAge());
				// 降序
				// return s2.getAge()-s1.getAge();
				// return s2.getAge().compareTo(s1.getAge());
			}
});
```
