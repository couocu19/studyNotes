# Mysql中的锁

## 分类

- ### 按照用法分

     共享锁，排他锁。

- ### 按封锁粒度分

   （封锁粒度，即封锁对象的大小称为封锁粒度。）

     按粒度分为**行级锁，页级锁，表级锁。**

  - #### 行级锁

    是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁的粒度最小，但是加锁的开销也越大。

    **行级锁又分为共享锁和排它锁。**

    ##### 特点：

    ​    开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

    ##### 用法：

    ```
    共享锁：(S锁 读锁)
       SELECT ... LOCK IN SHARE MODE;
    排它锁：(X锁 写锁)
       SELECT ... FOR UPDATE;
    ```

    

  - #### 表级锁

    是Mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，实现简单，资源消耗较少，被大部分Mysql引擎支持。

    最常使用的MYISAM与INNODB都支持表级锁定。

    ##### 表级锁定分为共享锁和排他锁。

    ##### 特点：

       开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

    ##### 用法：

    ```
    共享锁：
    LOCK TABLE table_name [ AS alias_name ] READ
    排它锁：
    LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
    ```

       

  - #### 页级锁

    是Mysql中介于行级锁和表级锁之间的一种锁。表级锁速度快，但冲突多；行级冲突少，但是速度慢。

    所以取了折中的页级，一次锁定相邻的一组记录。

    BDB支持页级锁。

    ##### 特点：

    ​    开销和加锁时间介于表锁和行锁之间；

    ​    会出现死锁；

    ​    锁定粒度介于表锁和行锁之间，并发度一般。

    

    ###  乐观锁和悲观锁

    ​    数据库管理系统（DBMS）中并发控制的任务就是确保在多个事务同时存取数据库中同一数据时不破坏事务的**隔离性**和数据库的**一致性**；

    ​    乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

    ###   悲观锁

        在数据库管理系统中，悲观控制是一种并发控制的方法。（又名"悲观锁"，缩写"PCC"）
        它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物执行的操作的某行数据应用了锁，那只有当这个事物把锁释放，其他事务才能够执行与该锁冲突的操作。
        悲观并发控制主要用于数据争用激烈的环境，以及并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
    #### 悲观锁的流程：
    
在对任意记录进行修改前，先尝试为该记录加上[排他锁](http://www.hollischuang.com/archives/923)（exclusive locking）。
    
如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    
如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    
其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
    
#### Mysql InnoDB中使用悲观锁：
    
要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySqL默认使用autocommit模式，即执行完一个更新操作后，Mysql会立刻将结果进行提交。
    
**set autocommit=0；**
    
  ```sql
    //0.开始事务
    begin;/begin work;/start transaction; (三者选一就可以)
    //1.查询出商品信息
    select status from t_goods where id=1 for update;
    //2.根据商品信息生成订单
    insert into t_orders (id,goods_id) values (null,1);
    //3.修改商品status为2
    update t_goods set status=2;
    //4.提交事务
    commit;/commit work;
    ```
    
    #### 优点和不足：
    
    #### 优点：
    
    悲观并发控制实际上是”先取锁再访问“的保守策略，为数据处理的安全提供了保证。
    
    #### 缺点：
    
      1.在效率方面，处理加锁的机制会让数据库产生额外的开销，还会增加产生死锁的机会；
    
      2.在只读型事务中由于不会产生冲突，也没必要使用锁，这样做只会增加系统负担；
    
      3.降低了并行性，一个事物如果锁定了某行数据，其他事物就必须等待该事务处理完才可以处理那行数。
    
    #### 
    
    ### 乐观锁：
    
    ```
    在关系数据库中，乐观并发控制是一种并发控制的方法。
    它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生所的情况下处理各自影响的那部分数据。
    在提交数据更新之前，每个事务会检查在该事物读取数据之后，有没有其他事物又修改了该数据。
    如果其他事务有更新的话，正在提交的事务会进行回滚。
    ```
    
    乐观锁（Optimistic Locking）相对于悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行更新提交的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
    
    
    
    相对于悲观锁，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是**记录数据版本。**
    
    ```
    数据版本，为数据增加一个版本标识。
    当读取数据时，将版本标识的值一同取出，数据每更新一次，同时会对版本进行更新。
    当我们提交更新时，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行对比，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期的数据。
    ```
    
    **乐观锁使用CAS（Compare And Swep）操作保证数据的一致性。**
    
    #### 实现数据版本的两种方式：
    
    #### 使用版本号：
    
    使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。
    
    ##### 优点：
    
      乐观并发控制相信事物之间的数据竞争的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。
    
    ##### 不足：
    
      但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事物都读取了数据库的某一行，经过修改孩子后写回数据库，这时就遇到了问题。
    
    #### 使用时间戳：
    
    
    
    ### Mysql常用存储引擎的锁机制
    
    ```
    MyISAM和MEMORY采用表级锁(table-level locking)
    BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
    InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
    ```
    
    #### InnoDB中的行锁与表锁
    
    InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。
    
    InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**
    
    
    
    在实际应用中，要特别注意InnodB行锁的特性，不然可能导致大量的锁冲突，从而影响并发性能。
    
    ```
    1.在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁。
    2.由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行 的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
    3.当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
    4.即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。
    ```
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
       
    
    
    
    ​    
    
     
    
    
    
    
    
    
    
     
  
   