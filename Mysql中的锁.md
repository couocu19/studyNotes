Mysql中的锁

## 分类

- ### 按照用法分

     共享锁，排他锁。

- ### 按封锁粒度分

   （封锁粒度，即封锁对象的大小称为封锁粒度。）

     按粒度分为**行级锁，页级锁，表级锁。**

  - #### 行级锁

    是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁的粒度最小，但是加锁的开销也越大。

    **行级锁又分为共享锁和排它锁。**

    ##### 特点：

    ​    开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

    ##### 用法：

    ```
    共享锁：(S锁 读锁)
       SELECT ... LOCK IN SHARE MODE;
    排它锁：(X锁 写锁)
       SELECT ... FOR UPDATE;
    ```

    

  - #### 表级锁

    是Mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，实现简单，资源消耗较少，被大部分Mysql引擎支持。

    最常使用的MYISAM与INNODB都支持表级锁定。

    ##### 表级锁定分为共享锁和排他锁。

    ##### 特点：

       开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

    ##### 用法：

    ```
    共享锁：
    LOCK TABLE table_name [ AS alias_name ] READ
    排它锁：
    LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
    ```

       

  - #### 页级锁

    是Mysql中介于行级锁和表级锁之间的一种锁。表级锁速度快，但冲突多；行级冲突少，但是速度慢。

    所以取了折中的页级，一次锁定相邻的一组记录。

    BDB支持页级锁。

    ##### 特点：

    ​    开销和加锁时间介于表锁和行锁之间；

    ​    会出现死锁；

    ​    锁定粒度介于表锁和行锁之间，并发度一般。

    

    ###  乐观锁和悲观锁

    ​    数据库管理系统（DBMS）中并发控制的任务就是确保在多个事务同时存取数据库中同一数据时不破坏事务的**隔离性**和数据库的**一致性**；

    ​    乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

    ###   悲观锁

        在数据库管理系统中，悲观控制是一种并发控制的方法。（又名"悲观锁"，缩写"PCC"）
        它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物执行的操作的某行数据应用了锁，那只有当这个事物把锁释放，其他事务才能够执行与该锁冲突的操作。
        悲观并发控制主要用于数据争用激烈的环境，以及并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
    #### 悲观锁的流程：
    

在对任意记录进行修改前，先尝试为该记录加上[排他锁](http://www.hollischuang.com/archives/923)（exclusive locking）。
    
如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    
如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    
其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
    

#### Mysql InnoDB中使用悲观锁：

要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySqL默认使用autocommit模式，即执行完一个更新操作后，Mysql会立刻将结果进行提交。
    
**set autocommit=0；**
    
  ```sql
    //0.开始事务
    begin;/begin work;/start transaction; (三者选一就可以)
    //1.查询出商品信息
    select status from t_goods where id=1 for update;
    //2.根据商品信息生成订单
    insert into t_orders (id,goods_id) values (null,1);
    //3.修改商品status为2
    update t_goods set status=2;
    //4.提交事务
    commit;/commit work;
  ```

#### 优点和不足：

#### 优点：

悲观并发控制实际上是”先取锁再访问“的保守策略，为数据处理的安全提供了保证。

#### 缺点：

  1.在效率方面，处理加锁的机制会让数据库产生额外的开销，还会增加产生死锁的机会；

  2.在只读型事务中由于不会产生冲突，也没必要使用锁，这样做只会增加系统负担；

  3.降低了并行性，一个事物如果锁定了某行数据，其他事物就必须等待该事务处理完才可以处理那行数。



### 乐观锁：

```
在关系数据库中，乐观并发控制是一种并发控制的方法。
它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生所的情况下处理各自影响的那部分数据。
在提交数据更新之前，每个事务会检查在该事物读取数据之后，有没有其他事物又修改了该数据。
如果其他事务有更新的话，正在提交的事务会进行回滚。
```

乐观锁（Optimistic Locking）相对于悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行更新提交的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

​        

相对于悲观锁，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是**记录数据版本。**

```
数据版本，为数据增加一个版本标识。
当读取数据时，将版本标识的值一同取出，数据每更新一次，同时会对版本进行更新。
当我们提交更新时，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行对比，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期的数据。
```

**乐观锁使用CAS（Compare And Swep）操作保证数据的一致性。**

#### 实现数据版本的两种方式：

#### 使用版本号：

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。

##### 优点：

  乐观并发控制相信事物之间的数据竞争的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。

##### 不足：

   但如果直接简单这么做，还是有可能会遇到不可预期的结果，

   例如：两个事物都读取了数据库的某一行，经过修改孩子后写回数据库，这时就遇到了问题。

   例如：如果第二个用户恰好在第一个用户提交更改之前读取了该对象，当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新获取该对象并做出更改。

​    在乐观锁环境中，会增加并发用户读取对象的次数。

#### 使用时间戳：

  乐观锁的第二种实现方式和第一种差不多，同样需要在乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳(timestamp),和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果时间戳一致则ok，否则就是版本冲突。

   ### Mysql常用存储引擎的锁机制
```
MyISAM和MEMORY采用表级锁(table-level locking)
BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
```

#### InnoDB中的行锁与表锁

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。

InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

在实际应用中，要特别注意InnodB行锁的特性，不然可能导致大量的锁冲突，从而影响并发性能。

```
1.在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁。
2.由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行 的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
3.当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
4.即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。
```



###    MVCC中的实现方式

#### MVCC概念：

   是数据库中一种并发控制的方法，通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。

Mysql InnodB存储引擎，实现的是基于多版本的并发控制协议--MVCC。

**MVCC最大的好处：**

​    **读不加锁，读写不冲突。**

#### 当前读：

   当前读，就是读取记录的最新版本，读取时还要保证其他并发实物不能修改当前记录，会对读取的记录进行加锁。

   举例：

```sql
select lock in share mode(共享锁)
select for update;
update,insert,delete(排它锁)
```

#### 快照读

   像不加锁的select操作就是快照读，即不加锁的非阻塞读。

   快照读的前提是隔离界别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于挺高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，在很多情况下，避免了加锁的操作，降低了开销；既然是基于多版本，快照读可能读到的并不一定是数据的最新版本，也可能是之前的历史版本。

#####   说白了MVCC就是为了实现读写不冲突，而这个读指的就是快照读，而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。



#### MVCC能解决什么问题？好处是什么？

数据库并发场景有三种，分别是：

- 读读：不存在任何问题，也不需要并发控制；
- 读写/写读：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读。
- 写写：有线程安全问题，可能会存在更新丢失的问题，**比如第一类更新丢失，第二类更新丢失。**

####  MVCC带来的好处？

   MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。所以他能解决的问题是：

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不阻塞读操作，提高了数据库并发读写的性能。
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。





#### MVCC的不同使用场景：

- MVCC+悲观锁

  MVCC解决读写冲突，悲观锁解决写写冲突；

- MVCC+乐观锁

  MVCC解决读写冲突，乐观锁解决写写冲突；

​       这种组合的方式就可以最大程度的提高数据库的并发性能，并决绝读写冲突，和写写冲突导致的问题。

#### MVCC的实现原理： 

  MVCC的实现原理主要是依赖记录中的**3个隐式字段，undo日志‘，Read View**实现的。

- 隐式字段：

  ```
  DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段
  
  DB_TRX_ID
  6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
  DB_ROLL_PTR
  7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
  DB_ROW_ID
  6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
  实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了
  ```

  

- undo日志：

  - insert undo log：

    代表事务在insert新纪录是产生的undo-log，知识书屋回滚时需要，并且在事务提交后立即被抛弃；

  - update undo log：

     事务在进行update或者delete时产生的undo log；

     不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清楚。

  ##### 注意：

     对MVCC有帮助的其实是update undo log。

  

  

  



 











  在读多写少的OLTP应用中，读写不冲突是非常重要的，这极大的增加了系统的并发性能，这也就是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。

   ```
在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：

SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号；
INSERT时，保存当前事务版本号为行的创建版本号；
DELETE时，保存当前事务版本号为行的删除版本号；
UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。
　　通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用。大多数读操作都不用加锁，读数据操作很简单、性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

　　在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录都会加上锁，保证其他事务不会再并发修改这条记录。

　　在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：

　　快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)　

select * from table where ?;
　　当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
　　所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

 

   ```

