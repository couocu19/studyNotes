# JVM学习笔记

## 7.22笔记

- ### 关于Parallel Scavenge垃圾收集器中的吞吐量和停顿时间

  #### 吞吐量的定义：

  吞吐量 = cpu用于运行代码的时间/cpu用于运行代码的时间+垃圾收集的时间

  简单来说，**吞吐量是应用程序线程用时占程序总用时的比例**。

  由以上公式可以看出，吞吐量的大小和垃圾收集时间有着密切的关系。

  只要GC线程是活动的，他们就会与应用程序线程争用当前可用cpu的时钟周期。

  #### 暂停时间/停顿时间：

  暂停时间是指，一个时间段内应用程序让与GC线程执行而完全暂停，即STW（stop the world）的时间。

  #### 吞吐量VS暂停时间

  在程序中我们会追求两个点：

     1.高吞吐量；

     2.低暂停时间；

  **高吞吐量**：

     高吞吐量可以高效的利用cpu的时间，尽快完成程序的运算任务，适合在后台运算而**不需要太多交互**的任务。 

     直觉上来看，吞吐量越高程序运算越快。

  **低暂停时间：**

     从用户的角度来看，不管是GC还是其他原因导致用户程序暂停都是不好的。这取决于应用程序的类型，有时候甚至短暂的暂停时间都会大端终端用户的 体验。

     因此，低暂停时间是十分重要到的，特别是对于一个交互式应用程序。

  ##### 吞吐量和暂停时间的矛盾：

  ​      不行的是“高吞吐量”和“低暂停时间”是一对相互竞争的目标。

  ​      注意：GC线程需要在一定的前提条件下安全地运行。例如，必须保证应用程序线程在GC线程试图确定哪些对象仍然被引用和没引用的时候不修改对象的状态。为此，GC期间应用程序必须停止。

  ​       然而，这会增加额外的线程调度的开销。直接开销是上下文的切换，间接开销是因为缓存的影响。

  ​       因此我们可以通过尽可能少运行GC来最大化吞吐量。例如，只有在不可避免的时候进行GC，来节省所有与他相关的开销。

  ​      但是，仅仅偶尔运行GC意味着每次GC将有很多工作要做，因为在此期间积累在堆中的对象数量很多。单个GC需要花更多的时间完成，从而导致了更高的平均和最大的暂停时间。

  ​      因此，如果考虑低暂停时间，最好频繁的运行GC以更快速的完成。这反过来又增加了开销并导致吞吐量下降，又回到了起点。

  ​     因此，在设计或者使用GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于最大吞吐量或最小暂停时间），或者尝试找到一个二者的折衷。

