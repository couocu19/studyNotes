# 算法笔记

## 5.14笔记

- ### 关于位移运算的基本知识

  移位运算符 是位操作运算符的一种。

  移位运算符可以在二进制的基础上对数字进行平移。

  按照平移的方向和填充数字的规则分为三种：<<(左移)、>>(右移)和>>>(无符号右移)。

  ```
  << : 左移运算符，num <<1,相当于num乘以2
  >> : 右移运算符，num >>1,相当于num除以2
  >>>: 无符号右移，忽略符号位，空位都以0补齐，（计算机中数字以补码存储，首位为符号位）。
  如：a  =  00110111，则a>>2    = 00001101，b=11010011，则b>>2   =  11110100；  
  如：a  =  00110111，则a>>>2  = 00001101，b=11010011，则b>>>2 =  00110100。
  ```


## 5.18笔记

- ### 用链表实现栈和队列实现

  **1.实现栈**

  ​      链表实现堆栈：栈的顶部即为链表头，实例变量first指向栈顶，当使用push()压入一个元素时会将该元素添加到表头，当使用pop()删除一个元素时会将该元素从表头删除，操作时间与元素个数无关。 

  ​       注意，Java有一个内置的库：java.util.Stack，它新增了几个不属于栈的用法，例如获取第i个元素，它还允许从栈底添加元素，所以它可以被当做队列使用！但需要栈的时候最好不要使用它，防止执行一些意外的操作。 

  ```java
  public class Stack<T>{
      private Node first = null;//栈顶，即最近添加的元素
      private int N = 0;//元素数量
      private class Node{
          T t;
          Node next;
      }
      public boolean isEmpty(){
          return first == null;//N ==0;
      }
      public int size(){
          return N;
      }
      public void push(T t){//即表头插入结点
          Node oldFirst = first;
          first = new Node();
          first.t = t;
          first.next = oldFirst;
          N++;
      }
      public t pop(){//即表头删除结点
          T t = first.t;
          first = first.next;
          N--;
          return t;
      }
  }
  ```

  **2.实现队列**

  ​       用链表实现队列：实例变量first指向队列的开头，实例变量last指向队列的结尾，将一个元素入列就将它添加到表尾（链表为空时需要将first和last都指向新结点），要将一个元素出列就删除表头的结点（链表为空时需要更新last的值），size()和isEmpty()方法的实现与Stack相同。

  ```java
  public class Queue<T>{
      Node first = null;
      Node last = null;
      int N = 0;
      private class Node{
          T t;
          Node next;
      }
      public boolean isEmpty(){
          return first == null;//N == 0;
      }
      public int size(){
          return N;
      }
      public void enqueue(T t){//向表尾添加元素
          Node oldLast = last;
          last = new Node();
          last.t = t;
          last.next = null;
          if(N == 0){
              first = last;
          }else{
              oldLast = last;
          }
          N++;
      }
      public t dequeue(){//从表头删除元素
          T t = first.t;
          first = first.next;
          if(N == 0)
              last = null;
          N--;
          return t;
      }
  }
  ```

  

## 6.3更新

- ### 递归算法的分析

​       最近在练习关于二叉树的题型，发现大多数问题的的解决都要用到递归，往细说，都要用到二叉树的前中后遍历的算法。

​        怎样理解二叉树的递归遍历算法？

​         过程大概为：根据递归体从二叉树自上而下进行，当遇到某一层递归体无法进行或者返回null时（遇到return;），就返回到上一层的递归体，而这时上一层递归体已经进行完毕，所以这时执行上一层递归体的下一句代码，依次进行。直到进行完每一层的递归体。

​        感觉很多题型还是不能很熟练的运用递归算法，感觉可能还是理解的不够深入8，之后希望再多加练习递归的题型吧。



## 8.17更新

### 跳表（skipList）

是一种基于有序链表的扩展，简称跳表。

#### 实现思路：

  利用类似索引的思想，提取出链表中的部分关键节点。

​    假如一个链表的序列为1--2--3--4-5--6--7，可以取出所有值为奇数的结点为关键节点，可以将这些关键节点看为索引。

 （当节点数量庞大时，这时可以进一步设置二级索引）

- #### 插入操作：

  就与上述的设置，如果要插入一个值为4的结点，不再需要和原结点依次比较，只需要比较关键节点7,5,3。

  总体来说，跳跃表的插入操作的时间复杂度为O(lgN),空间复杂度为O(N)。

- #### 删除操作：

  1.自上而下，查找第一次出现结点的索引，储层找到每一层对应的结点。（O（lgN））

  2.删除每一层查找到的结点，如果改成只剩下一个结点，删除一整个层。（O（lgN））

  

#### 跳表和二叉排序树的比较：

  跳表的优点是维持结构平衡的成本比较低，完全靠随机。而二叉排序树在多次插入删除之后，需要Rebanlance来重新调整结构平衡。



## 8.10学习更新

### 缓存淘汰算法---LRU算法

LRU（Least Recently Used），即最近最少使用。

#### 算法过程：

   将近期最少使用的数据淘汰掉。

   （如果数据最近这段时间一直都没有访问，那么将来被访问的概率也会很低。）

#### 实现：

   LRU一般采用**链表**方式实现，便于快速移动数据位置。

   1.一开始，缓存池是空的，插入数据不用担心容量不足的事情，这个过程就类似于队列的FIF

   2.当插入一定数量的数据后，缓存池已经满了（在实际应用中不会让达到缓存池的尺寸，一般到70&左右就要考虑淘汰机制了）

  3.当发现缓存池中的数据满之后，会将最早加入缓存池的数据淘汰掉。 

  4.如果这时查找缓存池中的某个元素，从时间点上是最近访问的元素，则会将该元素移动到链表的头部。

  5.之后的插入，查找操作和上述过程相同。

**（也可以使用哈希表方式来实现）**



## 8.27更新

- ### 力扣：滑动窗口题型

  ![image-20200827175758249](C:\Users\11310\AppData\Roaming\Typora\typora-user-images\image-20200827175758249.png)



大神写的诗。。

算法的大致逻辑：

```java
int left = 0, right = 0;
while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

时间复杂度： O(n).

算法框架：

```java
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...
        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```



## 9.3笔记

### 红黑树学习总结

- #### 二叉查找树有什么缺陷？

  ​        二叉查找树的性质为：左孩子小于父节点小于右孩子，这个性质能保证在一般情况下查找某一个节点的时间复杂度为O(lgN),但这只是一般情况，在极端情况下，例如按照从小到大或者从大到小的顺序插入到二叉查找树中时，会引起二叉查找树的及其不平衡，这时可能会导致而查找树退化为一个链表。

- #### 平衡二叉树的优势？解决了二叉查找树的什么问题？

  ​       平衡二叉树在二叉查找树的基础上，加了一条限制条件：即每个节点的左子树和右子树的高度差至多等于1.基于这种特点就就可以保证不会有大量节点偏向于一边的情况了。通过平衡树，解决了二叉查找树的缺点。对于n个结点的平衡树，最坏的时间复杂度也为O(lgN)。

- #### 为什么有了平衡二叉树还需要有红黑树？红黑树的出现解决了平衡二叉树的什么缺陷？

  ​       虽然平衡树解决了二叉查找树可能引起结点不平衡的缺点。但是我们知道，平衡树的这种结构特点是很难维持的。当向平衡树中插入一个元素时，很有可能直接破坏了平衡树的结构的情况，这时就需要通过旋转来恢复平衡树的结构。

  ​      所以，如果在插入，删除很频繁的场景中，平衡树需要频繁的进行调整，这回事平衡树的性能大打折扣，于是就有了红黑树。红黑树具有以下性质：

  ​      1.具有二叉查找树的特点。

  ​      2.根节点是黑色的。

  ​      3.叶子节点均为黑色的空节点（NIL）。

  ​      4.每个红色节点都有两个黑色的子节点。

  ​      5.根节点到每一个叶子结点的路径中都必须有相同数量的黑色节点。

  **例如下图（叶子节点没有画出来哦）**

  ![image-20200903120052465](C:\Users\11310\AppData\Roaming\Typora\typora-user-images\image-20200903120052465.png)

  所以，红黑树在插入，删除操作中，不会像平衡树那样，频繁的破坏红黑树的规则，所以不需要频繁的进行调整，这也是为什么大多数情况下使用红黑树的原因。

  **注意：在查找方面，平衡树必红黑树快。**

   **综上所述，红黑树的出现是为了解决平衡树在插入，删除等操作需要频繁调整的情况。**

- #### 红黑树有什么应用？

    java集合容器中的TreeMap，HashMap。

- #### 红黑树与哈希表的在不同场景的选择？

- #### 构建一课节点个数为n的红黑树的时间复杂度？

  **1.以插入的方式构建：**一个节点个数为n的红黑树的时间复杂度为NlgN。

     插入一个结点到红黑树中的复杂度为lgN。

    【 log(1) + log(2) + log(N-1) = log((N-1)!) = Nlog(N) 】

- #### 红黑树的各种操作的时间复杂度？

![image-20200903121020189](C:\Users\11310\AppData\Roaming\Typora\typora-user-images\image-20200903121020189.png)

 ps：采用迭代器遍历一课红黑树的时间复杂度？

   O(N)



