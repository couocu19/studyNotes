# 算法笔记

## 5.14笔记

- ### 关于位移运算的基本知识

  移位运算符 是位操作运算符的一种。

  移位运算符可以在二进制的基础上对数字进行平移。

  按照平移的方向和填充数字的规则分为三种：<<(左移)、>>(右移)和>>>(无符号右移)。

  ```
  << : 左移运算符，num <<1,相当于num乘以2
  >> : 右移运算符，num >>1,相当于num除以2
  >>>: 无符号右移，忽略符号位，空位都以0补齐，（计算机中数字以补码存储，首位为符号位）。
  如：a  =  00110111，则a>>2    = 00001101，b=11010011，则b>>2   =  11110100；  
  如：a  =  00110111，则a>>>2  = 00001101，b=11010011，则b>>>2 =  00110100。
  ```


## 5.18笔记

- ### 用链表实现栈和队列实现

  **1.实现栈**

  ​      链表实现堆栈：栈的顶部即为链表头，实例变量first指向栈顶，当使用push()压入一个元素时会将该元素添加到表头，当使用pop()删除一个元素时会将该元素从表头删除，操作时间与元素个数无关。 

  ​       注意，Java有一个内置的库：java.util.Stack，它新增了几个不属于栈的用法，例如获取第i个元素，它还允许从栈底添加元素，所以它可以被当做队列使用！但需要栈的时候最好不要使用它，防止执行一些意外的操作。 

  ```java
  public class Stack<T>{
      private Node first = null;//栈顶，即最近添加的元素
      private int N = 0;//元素数量
      private class Node{
          T t;
          Node next;
      }
      public boolean isEmpty(){
          return first == null;//N ==0;
      }
      public int size(){
          return N;
      }
      public void push(T t){//即表头插入结点
          Node oldFirst = first;
          first = new Node();
          first.t = t;
          first.next = oldFirst;
          N++;
      }
      public t pop(){//即表头删除结点
          T t = first.t;
          first = first.next;
          N--;
          return t;
      }
  }
  ```

  **2.实现队列**

  ​       用链表实现队列：实例变量first指向队列的开头，实例变量last指向队列的结尾，将一个元素入列就将它添加到表尾（链表为空时需要将first和last都指向新结点），要将一个元素出列就删除表头的结点（链表为空时需要更新last的值），size()和isEmpty()方法的实现与Stack相同。

  ```java
  public class Queue<T>{
      Node first = null;
      Node last = null;
      int N = 0;
      private class Node{
          T t;
          Node next;
      }
      public boolean isEmpty(){
          return first == null;//N == 0;
      }
      public int size(){
          return N;
      }
      public void enqueue(T t){//向表尾添加元素
          Node oldLast = last;
          last = new Node();
          last.t = t;
          last.next = null;
          if(N == 0){
              first = last;
          }else{
              oldLast = last;
          }
          N++;
      }
      public t dequeue(){//从表头删除元素
          T t = first.t;
          first = first.next;
          if(N == 0)
              last = null;
          N--;
          return t;
      }
  }
  ```

  

## 6.3更新

- ### 递归算法的分析

​       最近在练习关于二叉树的题型，发现大多数问题的的解决都要用到递归，往细说，都要用到二叉树的前中后遍历的算法。

​        怎样理解二叉树的递归遍历算法？

​         过程大概为：根据递归体从二叉树自上而下进行，当遇到某一层递归体无法进行或者返回null时（遇到return;），就返回到上一层的递归体，而这时上一层递归体已经进行完毕，所以这时执行上一层递归体的下一句代码，依次进行。直到进行完每一层的递归体。

​        感觉很多题型还是不能很熟练的运用递归算法，感觉可能还是理解的不够深入8，之后希望再多加练习递归的题型吧。



## 8.17更新

### 跳表（skipList）

是一种基于有序链表的扩展，简称跳表。

#### 实现思路：

  利用类似索引的思想，提取出链表中的部分关键节点。

​    假如一个链表的序列为1--2--3--4-5--6--7，可以取出所有值为奇数的结点为关键节点，可以将这些关键节点看为索引。

 （当节点数量庞大时，这时可以进一步设置二级索引）

- #### 插入操作：

  就与上述的设置，如果要插入一个值为4的结点，不再需要和原结点依次比较，只需要比较关键节点7,5,3。

  总体来说，跳跃表的插入操作的时间复杂度为O(lgN),空间复杂度为O(N)。

- #### 删除操作：

  1.自上而下，查找第一次出现结点的索引，储层找到每一层对应的结点。（O（lgN））

  2.删除每一层查找到的结点，如果改成只剩下一个结点，删除一整个层。（O（lgN））

  

#### 跳表和二叉排序树的比较：

  跳表的优点是维持结构平衡的成本比较低，完全靠随机。而二叉排序树在多次插入删除之后，需要Rebanlance来重新调整结构平衡。



## 9.10学习更新

### 缓存淘汰算法---LRU算法

LRU（Least Recently Used），即最近最少使用。

#### 算法过程：

   将近期最少使用的数据淘汰掉。

   （如果数据最近这段时间一直都没有访问，那么将来被访问的概率也会很低。）

#### 实现：

   LRU一般采用**链表**方式实现，便于快速移动数据位置。

   1.一开始，缓存池是空的，插入数据不用担心容量不足的事情，这个过程就类似于队列的FIF

   2.当插入一定数量的数据后，缓存池已经满了（在实际应用中不会让达到缓存池的尺寸，一般到70&左右就要考虑淘汰机制了）

  3.当发现缓存池中的数据满之后，会将最早加入缓存池的数据淘汰掉。 

  4.如果这时查找缓存池中的某个元素，从时间点上是最近访问的元素，则会将该元素移动到链表的头部。

  5.之后的插入，查找操作和上述过程相同。

**（也可以使用哈希表方式来实现）**



















