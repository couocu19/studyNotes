#  面经笔记

## 10.10笔记

- ### RPC学习

  - #### 和http的区别?

     RPC是一种远程过程调用的协议，使用这种协议向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。

  rpc(Remote Procedure Call,远程过程调用)最本质的区别是：rpc主要工作在tcp协议之上，而http协议主要工作在http协议之上，我们都知道http协议是工作在tcp协议之上的，按照效率来看的话，rpc更胜一筹。

  ```
  1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。
  
  2、RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。
  
    HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。
  
  3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。
  
  4、HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。
  
  5、HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。
  
  6、HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。
  ```

  

  - #### rpc基本的架构

    1.客户端（client），服务的调用方。

    2.服务端（server），真正的服务提供者。

    3.客户端存根，存放客户端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。

    4.服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

  - #### 同步调用和异步调用

    1.同步调用：是一种阻塞式调用，即调用方一直等待被调用方返回结果的模式。

    2.异步调用：是一种非阻塞式调用，一段异步代码还未执行完，可以继续执行下一段代码逻辑，当代吗执行完后，通过回调函数返回继续执行相应的逻辑，而不耽误其他代码的执行。

  - #### rpc和socket的区别？

    rpc是建立在Socket之上的，与Socket相比，传输相同的数据，rpc占用更多的网络带宽。Rpc树在Spcket基础上实现的，他比socket需要更多的网络和系统资源。

    

## 10.12笔记

- ### java 异常

  java中的异常处理包括：

  1.声明异常

  2.抛出异常   throw用于抛出异常

  3.捕获异常

  4.处理异常

  ```
  如下是常见的 Error 和 Exception：
  
  1）运行时异常（RuntimeException）：
  NullPropagation：空指针异常；
  ClassCastException：类型强制转换异常
  IllegalArgumentException：传递非法参数异常
  IndexOutOfBoundsException：下标越界异常
  NumberFormatException：数字格式异常
  
  2）非运行时异常：
  ClassNotFoundException：找不到指定 class 的异常
  IOException：IO 操作异常
  
  3）错误（Error）：
  NoClassDefFoundError：找不到 class 定义异常
  StackOverflowError：深递归导致栈被耗尽而抛出的异常
  OutOfMemoryError：内存溢出异常
  ```

- ### 操作系统

  - #### 缺页中断

  ```
  百度百科：
    缺页中断就是要访问的页不在主存中，需要操作系统将其调入主存后在进行访问。这时，被内存映射的文件实际上成为一个分页交换文件。
  ```

  ​       属于内部中断，也就是异常。属于异常中的故障。执行一条指令时，发现要访问的页没有在内存中，就停止该指令的执行，产生一个页不存在异常，对应的故障处理程序可以通过从外存加载该页到内存的方法来排除故障，之后，原先引起异常的指令就可以继续执行，从而不再产生异常。

  - #### 页面调度算法

    将新页面调入内存时，如果所有内存中的所有物理页已经分配出去，按照某种策略来废弃整个页面，将其所占据的物理页释放出来。

    - ##### 最佳淘汰算法---OPT(Optimal)

      该算法每次都淘汰以后永不使用的，或者最长时间后才会访问的页面。显然，这种算法会保证最低的缺页率。但是他是无法实现的，因为它必须知道页面“将来”的访问情况。但是该算法可以作为衡量其它算法优劣的一个标准。

    - ##### 先进先出算法---FIFO

      淘汰最先进入内存的页面。

    - ##### LRU

      淘汰内存中最久未使用的页面。、

  - #### 分页地址转换 ？？

  - #### 内存抖动

    本质是频繁的页调度行为，进程不断产生缺页中断置换一个页，又不断再次需要这个页。

    

    ## 10.18笔记

    1. ### jvm类加载机制复习

       #### 1.加载 

       ​      类加载器将.class文件加载到jvm内存中。讲的细一点：

       ​      1.通过类的全限定名获取此类的二进制字节流。

       ​      2.将类代表的静态存储结构转为方法区中的运行时数据结构。

       ​      3.在堆中生成一个此类的java.lang.class对象，作为访问方法区这些数据结构的入口。

       #### 2.验证

       ​      验证加载进jvm的.class文件是否符合jvm的要求，主要通过这几个方面来验证。

       ​      1.文件的数据格式的验证

       ​      2.元数据的验证

       ​      3.字节码文件的验证

       ​      4.符号引用的验证

       #### 3.准备

       ​     为类的静态变量分配内存，并为其进行初始值的赋值。

       #### 4.解析

       ​    将符号引用转为直接引用

       #### 5.加载

       ​    执行类的构造方法<client>，是由编译器自动收集类中的类变量的赋值操作和静态变量的语句块合并而成。

       ​    通俗的讲，就是为类的静态变量进行真正的赋值操作。

       ### 何时会触发类的初始化操作？

       - new一个实例的时候

       - 反射

       - 如果当前类继承了某个父类，需要先初始化父类

       - 包含main()方法的主类，必须是立刻初始化的。

         ... 



## 10.19笔记

- ### jvm内存区域复习

  - #### 程序计数器

    jvm中其实有一个字节码执行引擎，当需要执行字节码文件时，字节码执行引擎会通过程序计数器来记录当前线程所进行到的指令位置。

    其中，一个main线程会关联一个程序计数器，进而会执行其中的main方法。

  - #### 方法区

  - #### 堆

  - #### 虚拟机栈

    一个线程中每调用一个方法，就会为当前方法在虚拟机栈中开辟一个栈帧并将其压栈，栈帧中有一个局部变量表，当局部变量表中出现了引用类型的局部变量，该引用类型保存的是其所对应的实例在堆中的地址。

  - #### 本地方法栈



![image-20201019220256999](C:\Users\11310\AppData\Roaming\Typora\typora-user-images\image-20201019220256999.png)



- ### 破坏双亲委派模型的例子

  ####  Tomcat下的类加载机制。

  Tomcat自定义了Common，Catalina，Shared等类加载器，用来加载Tomcat自己的一些核心基础类库。

  然后tomcat对每个部署在里面的Web应用对应一个webapp类加载器，负责夹在我们部署的web应用类。

  即每个webapp负责加载自己对应的那个web应用的class文件，也就是我们写好的war包中的所有class文件，不会传导给上层的类加载器去加载。

- ### jvm内存模型的一些问题

  - #### 在for循环中创建对象，很容易造成OOM引起堆溢出，请问这种大文件导出怎么破？

    建议不要在for循环中创建对象，可以在外面改一个对象，在for 循环中对一个对象修改数据即可。

  - #### 新建的实例在堆内存，实例变量也在堆内存，是这样吗？

    是的

  - #### 关于父类和子类加载的问题

    如果只是加载父类，那么和子类没有什么关系，只要加载父类即可。但是如果加载子类，就**必须先加载父类，初始化父类，加载子类，初始化子类**。注意不是先加载父类，再加载子类，再初始化父类，再初始化子类。

  - #### 既然说类只有用到的时候才加载到内存中，那么new对象的时候肯定用到，是不是先经历过类的所有过程才将类实例化?

    是的，必须先加载类，再实例化对象。

  - #### 对于一个静态成员变量，多线程修改是否会有线程安全问题，为什么？

    静态成员变量在内存里只有一份，是属于类的，多个线程并发修改，一定会有并发问题，可能会导致数据出错。

  - #### 双亲委派模型保证了什么？有啥好处？为何说呢么必须要一级一级类加载器向上找？直接从顶层开始找不行吗？

    每一层类加载器对某个类的加载，上退给父类加载器，到顶层的加载器，如果发现加载不到，在下退给子类加载器来加载，这样可以保证绝对不会重复加载某一个类。

    为什么不从顶层加载？

    类加载器本身做的就是父子关系的模型。这种模型保证了代码的可扩展性。

    好处：

    保证每个层级的类加载器各司其职，而且不会重复加载一个类，否则，如果没有这个机制，岂不是两个层级的类加载器都可以重复加载同一个类。

  - #### 初始化之后是不是就有实例了?

    不是的，类的初始化阶段，仅仅是初始化类而已，跟对象无关，只有你new一个对象时才会构造一个对象出来。

  - #### 自定义的类加载器怎么写？

     自己写一个类，继承ClassLoader类，重写类加载方法，然后在代码里可以用自己的类加载器针对某个路径下的类加载到内存中。

  - #### 类加载器是把jar包中所有的类一次性全部加载进去嘛？

    不是。首先加载包含main方法的主类，接着是运行你写的代码的时候，用到了什么类就加载什么类。

## 10.20笔记

- ### jvm中的方法区会不会进行垃圾回收？何时进行和回收？

  答：会的。当满足以下条件时，会对方法区中的类进行回收。

  ​        1.该类的所有实例对象都已经从java堆内存里被回收。

  ​        2.加载该类的ClassLoader已经被回收。

  ​        3.最后，对该类的Class对象没有任何引用。

- ### 每个线程都有java虚拟机栈，里面也有方法的局部变量等参数，这个进程把虚拟机栈需要进行垃圾回收吗？为什么？

    答：不需要。jvm的垃圾回收机制只针对方法区和堆。

- ### jvm堆内存中的对象在什么情况下会从变成老年代对象？

  答：1.当一个对象在新生代中存活的年龄超过15次，就会从新生代对象变成老年代对象。(年龄15岁意思是经历了15次minor gc仍然存活的对象)

  ​       2.一个对象太大了，他会直接变成老年代对象而不经过新生代。

  ​       3.新生代垃圾回收之后，因为存活对象太多，导致大量对象直接进入老年代。

- ### idea设置jvm参数

  - #### 采用CMS垃圾回收配置

    ```
    -server
    -Xms1024m
    -Xmx2048m
    -XX:MaxPermSize=1024m
    -XX:ReservedCodeCacheSize=512m
    -XX:+UseConcMarkSweepGC
    -XX:+UseCodeCacheFlushing
    -XX:SoftRefLRUPolicyMSPerMB=50
    -ea
    -Dsun.io.useCanonCaches=false
    -Dsun.awt.keepWorkingSetOnMinimize=true
    -Djava.net.preferIPv4Stack=true
    -Djdk.http.auth.tunneling.disabledSchemes=""
    -Djsse.enablesSNIExtension=false
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:-OmitStackTraceInFastThrow
    -Dfile.encoding=UTF-8
    -Duser.name=qhong
    ```

    

  - #### 采用G1垃圾回收配置

    ```
    -server
    -XX:MetaspaceSize=128M 
    -XX:MaxMetaspaceSize=512M 
    -XX:+AlwaysPreTouch 
    -Xms128m
    -Xmx4g
    -XX:ReservedCodeCacheSize=512m
    -XX:+UseG1GC
    -XX:+UseStringDeduplication
    -XX:AutoBoxCacheMax=20000
    -ea
    -Dsun.io.useCanonCaches=false
    -Dsun.awt.keepWorkingSetOnMinimize=true
    -Djava.net.preferIPv4Stack=true
    -Djdk.http.auth.tunneling.disabledSchemes=""
    -Djsse.enablesSNIExtension=false
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:-OmitStackTraceInFastThrow
    -Dfile.encoding=UTF-8
    -Duser.name=qhong
    ```

  - #### 怎样在系统启动时设置jvm参数？

    ![image-20201020200913162](C:\Users\11310\AppData\Roaming\Typora\typora-user-images\image-20201020200913162.png)

    （首先右击你即将运行的主类，然后选择最后一项，就可以设置jvm参数具体如上图）

    ps：如果是在线上部署项目，怎样设置?

    ```
    使用java -jar命令即可，在java -jar命令中间加上jvm运行参数即可。
    ```

  - #### Springboot项目中的jvm参数设置实例

    ```
    -XX:MetaspaceSize=128m （元空间默认大小）
     
    -XX:MaxMetaspaceSize=128m （元空间最大大小）
     
    -Xms1024m （初始分配的堆内存）
     
    -Xmx1024m （最大允许分配的堆内存，按需分配）
     
    -Xmn256m （新生代大小）
     
    -Xss256k （棧最大深度大小）
     
    -XX:SurvivorRatio=8 （新生代分区比例 8:2）
     
    -XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）
    ```

- ### 对于一个百万级别访问量的订单支付系统，程序运行时进程的jvm参数可以怎样设置减少minor_gc的频率？

  这个问题的分析涉及到每秒多少访问量，每秒会在堆中创建多少个对象，所创建的对象的大小等等一系列的预估。

  假设我们现在有三台机器负载均衡处理并发请求，一个机器一秒可以处理30个请求。

  然后估计一个请求中需要创建的对象的大小是多少。一个对象的大小需要根据这个实体中的数据对象所对应的数据类型所占的字节数来估计，我们知道，int型数据类型占4个字节，long占8个字节，其他数据类型可以自己查。

  现在假设一个实例对象占的字节数为500Byte，一秒钟可能创建10个这样大小的对象，一次可以处理30个请求，算下来一秒钟所要占的堆内存大小大概为几百kb~1Mb之间。

  何时进行minor_gc就取决于新生代的内存空间的大小，为了防止minorgc的次数太频繁，这里可以将新生代的大小设置的稍微大一些。

  例如：

     ```
  堆大小：3G
  新生代：2G
     ```

  这样设置的话可能过半个小时或者一个小时才会进行minor_gc,大大减少了新生代垃圾回收的频率。



- ### 计算机网络复习

  - #### 浏览器上输入www.baidu.com之后到返回百度页面，这中间经历了哪些过程？

    - 输入www.baidu.com之后，接收到的是一个百度网站的域名，这时pc会找到DNS服务器，DNS服务器会解析域名得到百度网站的ip地址。
    - 这时会使用自己pc的子网掩码分别和本地pc以及百度的ip地址做与运算判断是否在一个子网内。
    - 判断之后，二者显然不在一个子网内，这时需要得到百度网站所在的网络地址，即百度所在的子网的网关的mac地址。这时需要通过交换机发送一个数据包到以太网帧，在通过广播得到所需要的mac地址。
    - 然后就可以通过应用层开始封装所要发送的数据。
    - 首先会在应用层生成一个http的请求报文，然后通过传输层将其封装在tcp的数据报中，并加上tcp的头，tcp头中包含了接收者的端口号和发送者的端口号；然后tcp数据报会发送到网络层，封装在ip数据报中，并加上ip头，ip头中包含了接收者的ip地址和发送者的ip地址，进而发送到以太网中，并被封装在以太网数据报中，并加上以太网标头，其中包含了发送者的网卡mac地址和接收者的网卡mac地址。
    - 上述发送数据的过程就是一个自上而下装包的过程，当交换机将以太网帧广播出去，并发送到对应网关之后这时百度服务器所在的网关会开始进行拆包操作，和装包的过程相反，自下而上进行拆包操作，最后到达应用层，得到http请求报文。
    - 然后百度服务器会根据请求报文生成响应报文，在进行一次装包操作。
    - 本地pc收到响应数据包之后会再次进行一次拆包操作，最后得到相应内容，通过浏览器渲染成页面，也就有了我们看到的页面。

    #### 总结：主要的过程就是进行了两次装包和两次拆包的过程。

