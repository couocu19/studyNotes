#  面经笔记

## 10.10笔记

- ### RPC学习

  - #### 和http的区别?

     RPC是一种远程过程调用的协议，使用这种协议向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。

  rpc(Remote Procedure Call,远程过程调用)最本质的区别是：rpc主要工作在tcp协议之上，而http协议主要工作在http协议之上，我们都知道http协议是工作在tcp协议之上的，按照效率来看的话，rpc更胜一筹。

  ```
  1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。
  
  2、RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。
  
    HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。
  
  3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。
  
  4、HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。
  
  5、HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。
  
  6、HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。
  ```

  

  - #### rpc基本的架构

    1.客户端（client），服务的调用方。

    2.服务端（server），真正的服务提供者。

    3.客户端存根，存放客户端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。

    4.服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

  - #### 同步调用和异步调用

    1.同步调用：是一种阻塞式调用，即调用方一直等待被调用方返回结果的模式。

    2.异步调用：是一种非阻塞式调用，一段异步代码还未执行完，可以继续执行下一段代码逻辑，当代吗执行完后，通过回调函数返回继续执行相应的逻辑，而不耽误其他代码的执行。

  - #### rpc和socket的区别？

    rpc是建立在Socket之上的，与Socket相比，传输相同的数据，rpc占用更多的网络带宽。Rpc树在Spcket基础上实现的，他比socket需要更多的网络和系统资源。

    

## 10.12笔记

- ### java 异常

  java中的异常处理包括：

  1.声明异常

  2.抛出异常   throw用于抛出异常

  3.捕获异常

  4.处理异常

  ```
  如下是常见的 Error 和 Exception：
  
  1）运行时异常（RuntimeException）：
  NullPropagation：空指针异常；
  ClassCastException：类型强制转换异常
  IllegalArgumentException：传递非法参数异常
  IndexOutOfBoundsException：下标越界异常
  NumberFormatException：数字格式异常
  
  2）非运行时异常：
  ClassNotFoundException：找不到指定 class 的异常
  IOException：IO 操作异常
  
  3）错误（Error）：
  NoClassDefFoundError：找不到 class 定义异常
  StackOverflowError：深递归导致栈被耗尽而抛出的异常
  OutOfMemoryError：内存溢出异常
  ```

- ### 操作系统

  - #### 缺页中断

  ```
  百度百科：
    缺页中断就是要访问的页不在主存中，需要操作系统将其调入主存后在进行访问。这时，被内存映射的文件实际上成为一个分页交换文件。
  ```

  ​       属于内部中断，也就是异常。属于异常中的故障。执行一条指令时，发现要访问的页没有在内存中，就停止该指令的执行，产生一个页不存在异常，对应的故障处理程序可以通过从外存加载该页到内存的方法来排除故障，之后，原先引起异常的指令就可以继续执行，从而不再产生异常。

  - #### 页面调度算法

    将新页面调入内存时，如果所有内存中的所有物理页已经分配出去，按照某种策略来废弃整个页面，将其所占据的物理页释放出来。

    - ##### 最佳淘汰算法---OPT(Optimal)

      该算法每次都淘汰以后永不使用的，或者最长时间后才会访问的页面。显然，这种算法会保证最低的缺页率。但是他是无法实现的，因为它必须知道页面“将来”的访问情况。但是该算法可以作为衡量其它算法优劣的一个标准。

    - ##### 先进先出算法---FIFO

      淘汰最先进入内存的页面。

    - ##### LRU

      淘汰内存中最久未使用的页面。、

  - #### 分页地址转换 ？？

  - #### 内存抖动

    本质是频繁的页调度行为，进程不断产生缺页中断置换一个页，又不断再次需要这个页。

    

    ## 10.18笔记

    1. ### jvm类加载机制复习

       #### 1.加载 

       ​      类加载器将.class文件加载到jvm内存中。讲的细一点：

       ​      1.通过类的全限定名获取此类的二进制字节流。

       ​      2.将类代表的静态存储结构转为方法区中的运行时数据结构。

       ​      3.在堆中生成一个此类的java.lang.class对象，作为访问方法区这些数据结构的入口。

       #### 2.验证

       ​      验证加载进jvm的.class文件是否符合jvm的要求，主要通过这几个方面来验证。

       ​      1.文件的数据格式的验证

       ​      2.元数据的验证

       ​      3.字节码文件的验证

       ​      4.符号引用的验证

       #### 3.准备

       ​     为类的静态变量分配内存，并为其进行初始值的赋值。

       #### 4.解析

       ​    将符号引用转为直接引用

       #### 5.加载

       ​    执行类的构造方法<client>，是由编译器自动收集类中的类变量的赋值操作和静态变量的语句块合并而成。

       ​    通俗的讲，就是为类的静态变量进行真正的赋值操作。

       ### 何时会触发类的初始化操作？

       - new一个实例的时候

       - 反射

       - 如果当前类继承了某个父类，需要先初始化父类

       - 包含main()方法的主类，必须是立刻初始化的。

         ... 





