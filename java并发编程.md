# java并发编程

## 几个重要概念

#### 进程：

​    是并发执行的程序在执行过程中进行**分配和管理资源的基本单位**，是一个动态概念，**竞争计算机系统资源的基本单位。**

​    程序一旦运行就是进程。更专业的来讲，进程是指程序执行的一个实例。

#### 线程：

​    **是进程的一个执行单元，是进程内科调度实体。**

​     是比进程更小的独立运行的基本单位。**线程也被称为轻量级子进程。**

#### 多线程：

   是一个同时执行多个线程的过程。

#### 多线程和多进程：

   多线程和多进程不同。线程之间共享内存区域以节省内存，上下切换线程要比切换进程容易很多，花费的时间更少。

   **注意：**一个程序至少有一个进程，一个进程至少有一个线程。

#### 进程和线程的区别：

  **1.地址空间：**同一进程的线程共享本进程的地址空间，但是进程之间则是独立的地址空间。

  **2.资源拥有**：同一进程之间的线程共享本地资源，但是进程之间的资源是相互独立的。

  **3.关于崩溃：**一个进程崩溃之后，在同一模式下不会对别的进程产生影响，但是一个线程崩溃之后整个进程都会死掉。所以多进程要比多线程健壮。

  **4.关于切换：**进程在进行切换时，消耗的资源大，效率噶。所以当涉及到频繁的切换时，多线程要好于多进程。同样**如果要求同时进行并且要大量共享某些变量的并发操作，只能用线程而不能使用进程。**

  **5.执行过程：** 进程可以独立执行，但是线程不可以。每个独立的进程有一个**程序运行的入口，顺序执行序列和程序入口**，但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

  **6.线程是处理器调度的基本单位，**但是进程不是。

  **7.并发执行：**线程和进程都可以并发执行。



#### 线程和进程的区别（高级）：

   1.关于数据段/地址空间：对于进程而言，每个进程有独立的数据段和堆栈段，每个进程有自己的地址空间，所以每启动一个线程就需要大量的堆栈，数据表需要来维护进程，系统的开销是比较“奢侈的”。但是对于线程而言，线程有自己独立的堆栈段，但是不同的线程之间共享数据段，且不同的线程之间共享相同的地址空间。

​    但是由于进程的独立性，一个进程的崩溃不会影响别的进程。但是一个线程一旦崩溃，则会导致整个进程坏死。

   2.通信机制：进程的通信机制比较复杂，但是线程的通信机制比较简单，因为线程之间有共享的数据段和地址空间。

   3.CPU系统：线程使cpu系统更加高效，因为操作系统会保证当线程数不大于cpu数目时，不同的线程运行于不同的CPU上。

   4.程序结构：当我们使用进程时，需要大量的if-else判断条件来判断pid，使程序结构变得繁琐。但是当我们使用线程的时候，基本可以甩掉他，但是当内部执行功能单元需要使用的时候还是需要使用，所以线程对程序机构的改进有很大的好处。

#### 什么是线程调度？

​     计算机通常只有一个cpu，在任意时刻只能执行一条机器指令，每个线程只有获得cpu的执行权才可以执行指令。

​    所谓多线程的并发运行，是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。

​    在线程池中，会有多个处于**就绪状态的线程**在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，**线程调度是指按照特定机制为多个线程分配CPU使用权。**



#### 线程调度的分类：

   **1.分时调度：**分时调度就是所有线程轮流拥有使用CPU的使用权，平均分配每个线程占用CPU的时间。

   **2.抢占式调度：**优先让优先级搞得线程使用cpu，如果线程的优先级相同，则会随机是选择一个，即优先级高的线程占用cpu的时间会更长，**java为抢占式调度。**

## Executor框架学习

### 1.什么是Executor框架

   线程池：线程池即为线程的集合，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度。

   线程：用于执行异步任务，单个线程既是工作单元也是执行机制。

   多线程：



# 7.21学习

## synchronized锁的实现原理

- ### 什么是线程安全?

  - #### 什么造成了线程安全问题？

  ​       1.共享数据（也称临界资源）。

  ​        2.存在多个线程共同操作共享数据。

  - #### 实现线程安全的策略？

     （互斥锁）

       当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作数据，其他线程必须等到该线程处理完数据后在进行，这种方式叫做**互斥锁**，即能达到互斥访问目的的锁，**也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。**

  ​       java中，关键字synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法或者代码块。

- ### synchronized底层

   java虚拟机中的同步是基于**进入和退出管程（Monitor）对象**实现，

  无论是显示同步（有明确的monitorenter（进入同步方法）和monitorexit（退出同步方法）指令，即同步代码块）还是隐式同步都是如此。

   

  在java语言中，同步用的最多的地方可能是被synchronized修饰的同步方法。

  同步方法并不是由monitorenter和monitorexit指令来实现同步的，而是由方法调用指令读取**运行时常量池**方法的ACC_SYNCHRONIZED标志来隐式实现的。
  
  #### synchronized实现的主要过程：
  
  ​    当多个线程访问同一个同步代码块时，这些线程首先都会被存放在ContentionList和EntryList中（先处于ContentinList中，当使用monitorexit方法之后并被唤醒之后就进入EntryList中），处于block状态，当一个线程执行了Monitorenter指令之后，会获得Monitor对象，而Monitor对象的底层是依赖操作系统中的Mutex Lock（互斥锁）实现的，这时Monitor对象会试图获取mutex锁，如果获取成功，则当前线程成功获取到了同步代码，接下来就会执行同步代码块中的方法，执行结束之后执行monitorexit指令释放monitor对象；如果获取mutex失败，就返回ContentionList中被挂起。
  
  **ps：**如果获取到mutex锁之后，调用wait（）方法，则会释放之前获得的mutex锁，并进入waitSet中进入阻塞状态，等待被唤醒。当线程调用notify方法唤醒之后，将重新进入EntryList中。

####        jvm堆中对象的结构：

​             1.对象头

​             2.（对象体）实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，   这部分按照4字节对齐。

​             3.（对齐字节）填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

- ### synchronized实现的三种方式

  - #### 同步普通方法

    sy----修饰普通方法并没有monitorenter和monitorexit指令，取而代之的是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。

    **jvm通过该标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。**                   

  - #### 同步方法快

    同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步的代码块的开始位置，monitorexit指令指向同步代码块的结束位置。

  - #### 同步静态方法

- ### 总结

  JVM基于进入和退出monitor对象实现方法同步和代码块的同步，但是二者实现的细节不一样。

  **1.代码块同步**：通过使用monitorenter和monitorexit指令实现。

  **2.同步方法：**ACC_SYNCHRONIZED修饰。



## 锁的竞争

​    随着锁的竞争，**锁可以从偏向级锁升级到轻量级锁，再升级到重量级锁**。

​    但是锁的升级是单向的，只能有低级升到高级，不会出现锁的降级。

​    JVM默认几秒之后开启偏向锁。

​     如果确定**应用程序中所有的锁都在竞争状态**，可以通过jvm参数关闭偏向锁 UseBiasedLocking  = false，那么程序将自动进入轻量级锁状态。

### 1.偏向锁（A线程独占锁，不用进行上下文切换，对象头标识）

​      在实际场景中，**如果一个同步方法不存在多线程竞争，并且总是由一个线程获取锁，如果每次还有阻塞线程，唤醒cpu从用户态转核心态，**那么对于cpu是一种资源的浪费，为了解决这类问题，就引入了偏向锁的概念。

​     偏向锁的核心思想是，如果不存在竞争的线程，一个线程获得了锁，那么锁进入了偏向模式。

​     这时Mark Word的结构也变成了偏向锁的结构，当这个线程再次请求锁时，无需再做任何同步操作，即省去了获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高了程序的性能。**所以，对于没有锁竞争的场合，偏向锁有很好的优化效果。**

​      当出现多个线程竞争锁之后偏向锁失效后，会升级为轻量级锁。

### 2.轻量级锁（A线程拥有锁，B线程获取，竞争，自旋（jdk1.7之后智能自转））

​       如果说偏向锁是为了解决同步代码在单线程下访问性能的问题，那么**轻量锁就是为了解决减少无实际竞争情况下，使用重量级锁产生的性能消耗。**

​       轻量锁，顾名思义，**轻量是相对于重量的问题，**使用轻量锁时，**不需要申请互斥量（mutex）**，**而是将mark word中的信息复制到当前线程的栈中，然后通过cas尝试修改mark word并替换成轻量锁，如果替换成功则执行同步代码。**

​      如果此时有线程2来竞争，并且也尝试cas修改mark word但是失败了，那么线程2会进入自旋状态，如果在自旋状态也没有修改成功，那么轻量锁将膨胀成重量级锁装状态，mark word会被修改成重量锁标记（10），**线程进入阻塞状态。**

​      当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但是不激烈，仍然可以用自旋锁优化，自旋失败孩子后再膨胀为重量级锁。    

### 3.自旋锁（A线程拥有锁，B线程自旋尝试获取）

​       **轻量级锁失败之后，虚拟机为了避免线程在操作系统挂起，会进行自旋锁的优化。**这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起，操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换需要从用户态转到核心态(内核态)，这个状态之间的转换需要相对比较长的时间，时间成本太高。

​       自旋锁会假设在不久将来，当前的线程可以获得锁，**因此虚拟机会让想要获取锁的线程做几个空循环（默认10次），在经历若干次的循环之后，如果得到锁，就顺利进入临界区。**

​      如果经历了循环还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。

​     这最后没办法也就只能升级成重量级锁。

### 4.重量级锁（B线程自旋获取不到锁，膨胀重量锁，阻塞A线程，直到B执行完）

​     **在jvm规范中，synchronized是基于监视器锁（monitor）来实现的。**

​     如在前文中提到的，它会在同步代码之前添加一个monitorenter指令，获取到该对象的monitor，同时它会在同步代码结束和异常处添加一个monitorexit指令去释放该对象的monitor，需要注意的是每一个对象都有一个monitor与之配对，当一个monitor被获取之后，也就代表该对象被monitorenter，它处于一个锁定状态，其他尝试获取该对象的monitor的线程会获取失败，只有当获取该对象的monitor执行了monitorexit指令之后，其他线程才可能获取该对象的monitor成功。 

​     所以从上面的描述中可以得出，监视器锁就是monitor，他是互斥的（mutex）。**由于他是互斥的，那么它的操作成本就非常高，包括系统调用引起的内核态与用户态切换，线程阻塞造成的线程切换等。**

​    因此，后来这种锁为“重量级锁”。庆幸的是在java6之后官方对synchronized较大优化，所以现在synchronized锁效率也优化的不错了。



# 7.23学习 

## java内存模型

- ### 为什么要有内存模型

  内存模型---Memory Model

  - **cpu和缓存的一致性：**

    ​    计算机在执行程序的时候，要和数据进行打交道，而计算机上的数据都存在主存中，即计算机的物理内存。随着cpu的发展，CPU的执行速度越来越快了 ，而由于内存的技术并没有太大的变化，所以从内存中取数据的执行过程和cpu执行数据的速度相差越来越大。

    ​     所以，为了解决cpu与内存执行速度不一致的问题，就在cpu和内存之间增加了高速缓存。

  - **缓存的概念：**

     缓存，即保存一份数据拷贝。特点是:速度快，内存小且昂贵。

  **那么基于以上，我们知道程序的执行过程变成了：**

  ​        当程序在运行过程中，会将运算需要的数据从主存复制一份到cpu高速缓存中，那么cpu在计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存中。

  - **多级缓存：**  

    随着cpu能力的不断上升，一层缓存就慢慢无法满足要求了，就逐渐衍生出多级缓存。

    按照数据读取顺序和与CPU结合的紧密程度，cpu可以分为一级缓存（L1），二级缓存（L2），部分高级CPU还有三级缓存（L3），**每一级缓存中所存储的全部属于都是下一级缓存的一部分**。

    这三种缓存的技术难度和制造成本是相对递减的，所以其内容也是相对递增的。

    **当有了多级缓存，程序的执行过程就变成了：**

       当cpu要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存中查找。

    - **单核cpu：**

      单核cpu只有一套L1，L2，L3缓存；

    - **多核cpu：**

      多核cpu，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。

  - **处理器优化和指令重排**

    ​    上面提到了要在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。

    ​     除了这种情况，还有一种硬件问题。

    ​    那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序处理，这就是**处理器优化**。同时，处理器会在乱序之后的结果进行重组，保证结果的正确性，也就是保证结果与殊勋执行的结果一致。

    ​    但是在真正的执行过程中，代码执行的顺序不一定按照代码的书写顺序来执行，可能和代码的书写顺序不同。
    
    ​    除此之外，很多编程语言的编译器也会有类似的优化，比如java虚拟机的即时编译器（JIT）也会做**指令重排。**

- ### 并发编程的问题

  我们所说的并发编程，为了保证数据的安全，需要满足以下三个特性：

  - **原子性：**

    指在一个操作中cpu不可以中途暂停然后在调度，即不能被中断操作，要不执行完成，要么就不执行。

  - **可见性：**

    指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

  - **有序性：**

    即程序执行的顺序按照代码的先后执行顺序执行。

    可以发现：

    **缓存一致性问题其实就是可见性问题；而处理器优化是可以导致原子性问题的；指令重排会导致有序性问题。**

- ### 什么是内存模型？

  ​       前面提到了，缓存一致性问题，处理器优化和指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的问题？

  ​      为了保证并发编程中可以满足原子性，可见性及有序性，有一个重要的概念。那就是-----内存模型。

  ​      **为了保证共享内存的正确性（可见性，有序性，原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**

  #### 内存模型解决并发问题采用的方式：

  ​      1.限制处理器优化

  ​      2.使用内存屏障

- ### 什么是java内存模型

  - #### java内存模型的目标：

    ​       **主要目标是定义程序中变量的访问规则**。即在虚拟机中将变量存储到主内存或者将变量从主内存中取出这样的底层细节。需要注意的是这里的变量跟我们写java程序中的变量不完全是等同的。

       这里的变量是指**实例字段，静态字段，构成数组对象的元素**，但是不包括**局部变量和方法参数**（因为是线程私有的）。

    ​       这里可以简单的认为主内存是java虚拟机内存区域中的**堆**，局部变量和方法参数是在**虚拟机栈**中定义的。

    ​       但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。

  - #### 概念：

    ​     **Java内存模型（Java Memory Model,JMM）就是一种符合内存模型的规范，屏蔽了各种硬件和操作系统的访问差异，保证了java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

  ​           java内存模型，一般指的是JDK 5 开始使用的新的内存模型。

  ​           java内存模型规定了所有变量都存储在主内存中，每条线程还有自己工作内存，线程的工作内存中保存了该线程中使用到的变量的主存 副本拷贝，**线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。**

  ​      不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量的传递需要自己的工作内存和主存之间进行数据同步进行。**

  

  - #### 涉及概念：

    - **主内存：**

      java虚拟机规定的所有变量都必须在主内存中产生，为了方便理解，可以认为是堆区。

      可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存的一部分。

    - **工作内存：**

      ​     java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的。为了方便理解，可以理解为虚拟机栈。

      ​     可以与前面的高速缓存相比。线程的工作内存保存了线程需要的变量在主存中的副本拷贝。

      ​     虚拟机规定，线程对主内存中变量到的修改必须在**工作内存**中进行，**而不能直接写主内存中的变量。**不同的线程之间也不能互相访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来进行中介进行传递。

    

  - #### 工作内存与主内存交互

    ​    物理机的告诉缓存和主内存之间的交互有协议，同样，java内存中线程的工作内存和主内存的交互是由java虚拟机定义的8种操作来完成的，每种操作都必须是原子性的。

      （double和long类型在某些平台例外）

    ​    java虚拟机中主内存和工作内存的交互，就是一个变量如何从主内存传到工作内存中，如何把修改后的变量从工作内存同步回主内存。

    - **lock（锁定）：**作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线程独占这个变量。

    - **unlock（解锁）：**作用于主内存变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定。

    - **read（读取）：**作用于主存变量，**表示把一个主内存变量的值传输到线程的工作内存**，以便随后的load操作使用。

      

    - **load（载入）：**作用用于线程的工作内存的变量，表示吧read操作从主内存中读取的变量的值放到工作内存的**变量副本**中。（副本是相对于主内存的变量而言的）

    - **use（使用）：**作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节码指令时就执行该操作。

    - **assign（赋值）：**作用于工作内存的变量，表示**把执行引擎的结果赋值给工作内存的变量**，每当虚拟机遇到一个给变量赋值的字节码的指令时就会执行操作。

    - **store（存储）：**作用于工作内存变量，**把工作内存中的一个变量的值传递给主存**，以便随后的write操作使用。

      

    - **write（写入）：**作用于主内存的变量，吧store操作从工作内存中得到的变量的值放入主存变量中。

     

    ​      如果要把一个变量从主存中传入工作内存中，就要顺序的执行read和load操作，如果要把一个变量从工作内存回写到主内存，就要顺序的执行store和write操作。

    ​      **对于普通变量，虚拟机知识要求顺序的执行，并没有要求连续的执行，所以如下也是正确的。**

    ​      **对于两个线程，分别从主内存中读取变量a和b的值，并不一定要 read a；load a；read b；load b。**

    也可能出现如下执行顺序：read a；read b；load b；load a；（对于volatile修饰的变量也会有一些其他规则），对于以上操作，虚拟机也定了一系列规则，在执行这8种操作的时候必须遵循以下规则：
  
    - **不允许read和load，store和write操作之一单独出现**，也就是不允许从主存读取了变量的值但是工作内存不接收的情况；或者不允许从工作内存将变量的值写回主内存但是主内存不接收到的情况。
    - 不允许一个线程丢弃最近的assgin操作，**也就是不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存。**
    - **不允许一个线程回写没有修改的变量到主内存，**也就是如果线程工作内存中的变量没有发生过任何assign操作，是不允许将该变量的值写到主内存。
    - 变量只能在主内存中产生，不允许在工作内存中直接使用一个未初始化的变量，也就是没有执行load或者assign操作。
    - 一个变量在同一时刻只能被一个线程进行lock操作，但是**同一个线程对一个变量加锁后，可以继续加锁**，同时释放锁的时候释放次数必须和加锁次数相同。
    - 对变量进行lock操作，就会清空工作空间该变量的值，执行引擎使用这个变量之前，需要重新load或者assign操作初始化变量的值。
  - 不允许对没有lock的变量执行unlock操作。
    - 对一个变量执行unlock操作之前，必须先把变量同步回主内存中。也就是说执行store和write操作。

    最重要的是，这8个动作必须是原子的，不可分割的。

    针对volatile修饰的变量，会有一些特殊规定。

  

  ## 7.25学习更新

  ### volatile修饰的变量的特殊规则

  ​     关键字volatile可以说是Java虚拟中提供的**最轻量级的同步机制。**

  ​     Java内存模型对volatile专门定义了一些特殊的访问规则。

  ​    假定T表示一个线程，v和W分别表示两个volatile修饰的变量，那么进行read，load，use，assign，store和write操作的时候需要满足以下条件：
  
  - **只有当线程T都变量V执行的前一个操作时load时，才能对V执行use操作；通知只有线程T对变量V执行的后一个操作是use时，线程T对变量V才能执行load操作**。所以，线程T对变量的use动作和线程T对变量V的read，load动作相关联，必须一起出现。即一个线程在使用一个变量之前必须从主内存中获取到该变量的最新值，用于保证线程T能看得见其它线程对变量V的最新的修改后的值。
  - **只有当线程T对V执行的前一个动作时assign时，对V执行的后一个动作才能时store操作，同时只有当T对V执行的后一个操作时store时，前一个动作才能时assign操作。**所以，线程对变量的assign操作和线程T对变量的store，write操作是相关联的，必须同时出现。即在T的工作内存中，每次修改变量V之后必须立刻同步会主内存，用于保证线程T对V变量的修改能被别的线程看到。
  - **在同一个线程内部，被volatile修饰的变量不会被指令重排序，**保证代码的执行顺序和程序的顺序相同。

#### 总结：

​     前两条可概括为，volatile类型的变量保证对所有线程的可见性；

​     第三条为：volatile类型的变量禁止指令重排序优化。

#### 优点：

​    跟其他保证并发安全的工具相比，volatile的性能会好一些。

​    在某些情况下，volatile的同步机制性能要优于锁（使用synchronized关键字或者java.util.concurrent包中的锁)。

   但是现在由于虚拟机对锁的不断优化和实行的许多消除都工作，很难有一个量化的比较。

   与自己相比，就可以确定一个原则：volatile变量的读取和普通变量的读操作几乎没有差异，但是写操作性能会差一点，慢一点，因为要在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。



### long和double变量的特殊规则

​     Java内存模型要求对主内存和工作内存交换的8个动作是原子的，但是对long和double两种数据类型有一写些特殊规定。

​     对于这两种数据类型，Java虚拟机规范对Java内存模型中特别定义了一条相对宽松的规则：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，也就是允许虚拟机不保证对64为数据的read，load，store，write这四个动作的操作是原子的。

​    这也就是我们常说的long和double的非原子性协定。



### 并发内存模型的实质

​    Java内存模型围绕着并发过程中如何处理**原子性，可见性和顺序性**这三个特征来设计。

- #### 原子性：

  ​       由Java内存模型保证内存的原子性的操作有read，load，use，assgin，store，write六种操作。如果扩大一些范围，lock和unlock也可实现。lock和unlock虽然没有被虚拟机直接开给用户使用，但是提供了字节码层次的指令monitorenter和monitorexit对应这两个操作，对应到Java代码也就是synchronized关键字，因此在synchronized块之间的代码都具有原子性。

- #### 可见性：

  ​       可见性指的就是对一个线程对某个变量的修改可以立即被其它线程感知到。具体而言就是，变量在工作内存中的值一旦被修改就必须写回到主内存中，当需要使用一个变量时必须从主内存中重新获取。即以来主内存为中介来保证多线程下变量对其它线程的可见性。

  ​      除了volatile，synchronized和final也可以保证可见性。synchronized关键字是通过unlock之前必须把变量同步回主存中，final则是初始化之后就不会被修改，所以只要在初始化过程中没有把this指针传递出去也能保证对其它线程的可见性。

- #### 有序性：

​          有序性从不同角度看是不同的。单纯单线程看都是有序的，但到了多线程中就会跟我们想象的不一样。

​          如果说本线程内部观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。

​         前半句的意思为：线程内表现为串行的语义；后半句指的是“指令重排序”现象和主内存与工作内存之间的同步存在延迟现象。

​          保证有序性的关键字有volatile和synchronized关键字，前者通过“禁止代码重排列”实现，后者通过一个变量同一时刻hi只能有一个线程对其进行lock操作来保证。





### 先行并发原则

- #### 概念：是判断数据是否存在竞争，线程是否安全的主要依据。

- #### java内存模型自带的先行并发原则有哪些？

  - **程序次序原则**
  
    在同一个线程内部，按照代码的逻辑顺序，书写在前的代码先行发生于写在后面的，准确的说是，在控制流之前的先行发生于控制流之后的，而不是按照代码顺序，因为会有分支，循环，跳转等出现。
  
  - **管程锁定原则**
  
    （可以通过synchronized关键字实现）
  
    一个unlock操作先行发生于后面对于同一个锁的lock操作。这里需要注意的是对同一个锁，后面指的是时间上的后面。
  
  - **volatile变量原则**
  
    对一个volatile变量的写操作先行发生于后面对于这个变量的读操作，这里的后面指的也是时间上的后面。
  
  - **程序启动原则**
  
    Thread对象的start()方法先行发生于该线程的每个动作。
  
    但是，如果你错误的使用了线程，直接调用该线程的run()方法，那么上述说法是不成立的，因为这时也就不是线程了。
  
  - **线程终止原则**
  
    线程中的所有操作都先行发生于对此线程的终止检测。可以通过Thread.join()和Thread.isAlive()的返回值来检测线程是否已经终止执行。
  
  - **线程中断原则**
  
    对线程interrupt()方法的调用先行发生于被中断的线程的代码检测到中断事件的发生。
  
  - **对象终结原则**
  
    一个对象的初始化完成先行发生于他的finalize方法的执行，也就是初始化方法先行发生于finalize方法。
  
  - **传递性**
  
    如果操作A先行发生于操作B，操作B先行发生于操作c，那么操作A先行发生于操作C。
  
  
  
  
  
  ​      





