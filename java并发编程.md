# java并发编程

## 几个重要概念

#### 进程：

​    是并发执行的程序在执行过程中进行分配和管理资源的基本单位，是一个动态概念，**竞争计算机系统资源的基本单位。**

​    程序一旦运行就是进程。更专业的来讲，进程是指程序执行的一个实例。

#### 线程：

​    **是进程的一个执行单元，是进程内科调度实体。**

​     是比进程更小的独立运行的基本单位。**线程也被称为轻量级子进程。**

#### 多线程：

   是一个同时执行多个线程的过程。

#### 多线程和多进程：

   多线程和多进程不同。线程之间共享内存区域以节省内存，上下切换线程要比切换进程容易很多，花费的时间更少。

   **注意：**一个程序至少有一个进程，一个进程至少有一个线程。

#### 进程和线程的区别：

  **1.地址空间：**同一进程的线程共享本进程的地址空间，但是进程之间则是独立的地址空间。

  **2.资源拥有**：同一进程之间的线程共享本地资源，但是进程之间的资源是相互独立的。

  **3.关于崩溃：**一个进程崩溃之后，在同一模式下不会对别的进程产生影响，但是一个线程崩溃之后整个进程都会死掉。所以多进程要比多线程健壮。

  **4.关于切换：**进程在进行切换时，消耗的资源大，效率噶。所以当涉及到频繁的切换时，多线程要好于多进程。同样**如果要求同时进行并且要大量共享某些变量的并发操作，只能用线程而不能使用进程。**

  **5.执行过程：** 进程可以独立执行，但是线程不可以。每个独立的进程有一个**程序运行的入口，顺序执行序列和程序入口**，但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

  **6.线程是处理器调度的基本单位，**但是进程不是。

  **7.并发执行：**线程和进程都可以并发执行。



#### 线程和进程的区别（高级）：

   1.关于数据段/地址空间：对于进程而言，每个进程有独立的数据段和堆栈段，每个进程有自己的地址空间，所以每启动一个线程就需要大量的堆栈，数据表需要来维护进程，系统的开销是比较“奢侈的”。但是对于线程而言，线程有自己独立的堆栈段，但是不同的线程之间共享数据段，且不同的线程之间共享相同的地址空间。

​    但是由于进程的独立性，一个进程的崩溃不会影响别的进程。但是一个线程一旦崩溃，则会导致整个进程坏死。

   2.通信机制：进程的通信机制比较复杂，但是线程的通信机制比较简单，因为线程之间有共享的数据段和地址空间。

   3.CPU系统：线程使cpu系统更加高效，因为操作系统会保证当线程数不大于cpu数目时，不同的线程运行于不同的CPU上。

   4.程序结构：当我们使用进程时，需要大量的if-else判断条件来判断pid，使程序结构变得繁琐。但是当我们使用线程的时候，基本可以甩掉他，但是当内部执行功能单元需要使用的时候还是需要使用，所以线程对程序机构的改进有很大的好处。

#### 什么是线程调度？

​     计算机通常只有一个cpu，在任意时刻只能执行一条机器指令，每个线程只有获得cpu的执行权才可以执行指令。

​    所谓多线程的并发运行，是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。

​    在线程池中，会有多个处于**就绪状态的线程**在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配CPU使用权。

#### 线程调度的分类：

   **1.分时调度：**分时调度就是所有线程轮流拥有使用CPU的使用权，平均分配每个线程占用CPU的时间。

   **2.抢占式调度：**优先让优先级搞得线程使用cpu，如果线程的优先级相同，则会随机是选择一个，即优先级高的线程占用cpu的时间会更长，**java为抢占式调度。**

## Executor框架学习

### 1.什么是Executor框架

   线程池：线程池即为线程的集合，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度。

   线程：用于执行异步任务，单个线程既是工作单元也是执行机制。

   多线程：



# 7.21学习

## synchronized锁的实现原理

- ### 什么是线程安全?

  - #### 什么造成了线程安全问题？

  ​       1.共享数据（也称临界资源）。

  ​        2.存在多个线程共同操作共享数据。

  - #### 实现线程安全的策略？

     （互斥锁）

       当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作数据，其他线程必须等到该线程处理完数据后在进行，这种方式叫做**互斥锁**，即能达到互斥访问目的的锁，**也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。**

  ​       java中，关键字synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法或者代码块。

- ### synchronized底层

   java虚拟机中的同步是基于**进入和退出管程（Monitor）对象**实现，

  无论是显示同步（有明确的monitorenter（进入同步方法）和monitorexit（退出同步方法）指令，即同步代码块）还是隐式同步都是如此。

   

  在java语言中，同步用的最多的地方可能是被synchronized修饰的同步方法。

  同步方法并不是由monitorenter和monitorexit指令来实现同步的，而是由方法调用指令读取**运行时常量池**方法的ACC_SYNCHRONIZED标志来隐式实现的。

####        jvm堆中对象的结构：

​             1.对象头

​             2.（对象体）实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，   这部分按照4字节对齐。

​             3.（对齐字节）填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

- ### synchronized实现的三种方式

  - #### 同步普通方法

    sy----修饰普通方法并没有monitorenter和monitorexit指令，取而代之的是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。

    jvm通过该标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。                   

  - #### 同步方法快

    同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步的代码块的开始位置，monitorexit指令指向同步代码块的结束位置。

  - #### 同步静态方法

- ### 总结

  JVM基于进入和退出monitor对象实现方法同步和代码块的同步，但是二者实现的细节不一样。

  **1.代码块同步**：通过使用monitorenter和monitorexit指令实现。

  **2.同步方法：**ACC_SYNCHRONIZED修饰。



## 锁的竞争

​    随着锁的竞争，**锁可以从偏向级锁升级到轻量级锁，再升级到重量级锁**。

​    但是锁的升级是单向的，只能有低级升到高级，不会出现锁的降级。

​    JVM默认几秒之后开启偏向锁。

​     如果确定**应用程序中所有的锁都在竞争状态**，可以通过jvm参数关闭偏向锁 UseBiasedLocking  = false，那么程序将自动进入轻量级锁状态。

### 1.偏向锁（A线程独占锁，不用进行上下文切换，对象头标识）

​      在实际场景中，**如果一个同步方法不存在多线程竞争，并且总是由一个线程获取锁，如果每次还有阻塞线程，唤醒cpu从用户态转核心态，**那么对于cpu是一种资源的浪费，为了解决这类问题，就引入了偏向锁的概念。

​     偏向锁的核心思想是，如果不存在竞争的线程，一个线程获得了锁，那么锁进入了偏向模式。

​     这时Mark Word的结构也变成了偏向锁的结构，当这个线程再次请求锁时，无需再做任何同步操作，即省去了获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高了程序的性能。**所以，对于没有锁竞争的场合，偏向锁有很好的优化效果。**

​      当出现多个线程竞争锁之后偏向锁失效后，会升级为轻量级锁。

### 2.轻量级锁（A线程拥有锁，B线程获取，竞争，自旋（jdk1.7之后智能自转））

​       如果说偏向锁是为了解决同步代码在单线程下访问性能的问题，那么**轻量锁就是为了解决减少无实际竞争情况下，使用重量级锁产生的性能消耗。**

​       轻量锁，顾名思义，**轻量是相对于重量的问题，**使用轻量锁时，不需要申请互斥量（mutex），而是将mark word中的信息复制到当前线程的栈中，然后通过cas尝试修改mark word并替换成轻量锁，如果替换成功则执行同步代码。

​      如果此时有线程2来竞争，并且也尝试cas修改mark word但是失败了，那么线程2会进入自旋状态，如果在自旋状态也没有修改成功，那么轻量锁将膨胀成重量级锁装状态，mark word会被修改成重量锁标记（10），**线程进入阻塞状态。**

​      当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但是不激烈，仍然可以用自旋锁优化，自旋失败孩子后再膨胀为重量级锁。    

### 3.自旋锁（A线程拥有锁，B线程自旋尝试获取）

​       **轻量级锁失败之后，虚拟机为了避免线程在操作系统挂起，会进行自旋锁的优化。**这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起，操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换需要从用户态转到核心态，这个状态之间的转换需要相对比较长的时间，时间成本太高。

​       自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让想要获取锁的线程做几个空循环（默认10次），在经历若干次的循环之后，如果得到锁，就顺利进入临界区。

​      如果经历了循环还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。

​     这最后没办法也就只能升级成重量级锁。

### 4.重量级锁（B线程自旋获取不到锁，膨胀重量锁，阻塞A线程，直到B执行完）

​     在jvm规范中，synchronized是基于监视器锁（monitor）来实现的。

​     如在前文中提到的，它会在同步代码之前添加一个monitorenter指令，获取到该对象的monitor，同时它会在同步代码结束和异常处添加一个monitorexit指令去释放该对象的monitor，需要注意的是每一个对象都有一个monitor与之配对，当一个monitor被获取之后，也就代表该对象被monitorenter，它处于一个锁定状态，其他尝试获取该对象的monitor的线程会获取失败，只有当获取该对象的monitor执行了monitorexit指令之后，其他线程才可能获取该对象的monitor成功。 

​     所以从上面的描述中可以得出，监视器锁就是monitor，他是互斥的（mutex）。由于他是互斥的，那么它的操作成本就非常高，包括系统调用引起的内核态与用户态切换，线程阻塞造成的线程切换等。

​    因此，后来这种锁为“重量级锁”。庆幸的是在java6之后官方对synchronized较大优化，所以现在synchronized锁效率也优化的不错了。









