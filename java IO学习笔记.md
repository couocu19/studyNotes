# java I/O学习笔记

## 一.概览

java IO可以分为以下几类：

- 磁盘操作：File
- 字节操作：InputStream和OutputStream
- 字符操作：Reader和Writer
- 对象操作：Serializable
- 网络操作：Socket
- 新的输入/输出：NIO



## 二.同步/异步/阻塞/非阻塞

### **引入：**

  **java 中的oio是阻塞的，nio是非阻塞的**

   **NodeJS的IO是异步的**

**首先给出结论：**

   1.异步/同步 与 阻塞/非阻塞之间没有必然的联系。

2. 同步IO可以是阻塞，也可以是非阻塞的。
3.  **异步IO就是异步IO，他一定是非阻塞的**，不存在异步阻塞IO的说法。



#### 几个概念：

##### 文件描述符：

   1.linux中，每打开一个文件都有一个小的整数与之对应，这就是文件描述符。

   2.内核（kernel）利用文件描述符（file descriptior）来访问文件。文件描述符是非负整数。打开现存文件或者新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。

   3.文件描述符是linux里面的叫法，windows里面有类似用来描述文件的文件句柄。

##### 用户空间/内核空间

  1.操作系统的核心是内核，**独立于普通的应用程序**，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。

  2.为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

##### 缓存I/O：

   1.在linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中。

   **2.即数据会先拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。**



##### 五种IO模型：

​     **同步IO：**

- 阻塞式IO；

- 非阻塞式IO；

- IO复用（select，poll，epoll...）；

- 信号驱动式IO（SIGIO）;

  **异步IO：**

- 异步IO（POSIXD的aio_系列函数）；



### 1.阻塞式IO

​    我们手上有一个socket，现在希望从这个socket读出点数据，我们会对这个socket调用recvfrom方法。

在默认情况下，**recvfrom方法会被阻塞，直到从指定的socket上收到数据才会返回**，**返回时，buf中已经填充好了数据，**阻塞的过程可分为两段；

​     **等待kernel准备好从网络上准备的数据报+等待收到的报文被从kernel赋值到buf中**，只有在这两个过程全部完成后，recvfrom方法才会返回。



### 2.非阻塞式 IO

​     还是上面的recvfrom方法，如果将其设置为非阻塞式（flag与MSG_DONTWAIT异或 ），情况就有所不同了：

​      **在内核没有准备好数据报时，调用recvfrom方法会立刻返回异常码。（这一段是非阻塞的）**

​      如果内核已经准备好数据，调用recvfrom方法则会在数据报被从kernel拷贝到buf中后返回。（这一段是同步的！）

​       也就是说，**阻塞与非阻塞式的IO的主要区别在于等待数据报准备好的第一阶段，至于将数据从kernel拷贝到buf的过程中，二者都是同步的。**

​    【注意】

​       非阻塞IO存在缺陷，因为在轮询一个socket是否可读的过程会直接占满一个core，如果想要减少cpu资源占用的资源的话，又会增加编程的复杂度。



### 3.IO的多路复用

**本质：**

   通过一种机制（系统内核缓冲IO数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者是写就绪），能够通知程序进行相应的读写操作。

   **优势**：

  系统开销小，系统不必创建进程/线程，也不必维护这些进程/县城管，从而大大减小了系统的开销。

  **理解：**

​      当使用io多路复用时，有多个C端同时发出请求，这些IO操作会被selector（epoll，kqueue）给暂时挂起，入内存队列。

​      此时S端可以自己选择什么时候读取，处理这些io，也就是说S端可以hold多个io

   IO的多路复用有 select/poll/epoll这几种方式

- #### select方法

​      select方法的返回值代表当前可以操作的fd的数量，如果返回值大于0，说明准备就绪，下一步就可以调用recvfrom方法从就绪的fd中读取数据了

​      select方法是否阻塞，与timeout参数有关系。

​     **如果timeout被设置为0，那么select是非阻塞的**，对select的调用会立刻返回。

​     **如果timeout被设置为非0，则select会阻塞**，直到有fd可读，或者timeout到期为止。

​     总的来说，**IO多路复用是同步阻塞的，**但主要是阻塞在对select/poll/epoll方法的调用上，后序的recvfrom则是同步的。

  **总结**：

（IO多路复用，实际上跟阻塞IO差不多，只是IO多路复用可以同时监听多个fd罢了，这样就减少了为每个需要监听的fd开启一个线程的开销。）

   **1.基本原理：**

​        select函数监视的文件描述符分为三类，分别是writefds，readfds和exceptfds。

​       调用之后select函数会阻塞（当timeout不为0时）,直到有文件描述符（fd）就绪（有数据可读，可写或者有except），或者超时（timeout指定等待时间，如果立即返回则设为null即可），函数返回。

​      当select函数返回后，若返回值大于0，可通过遍历fdset，来找到就绪的描述符。

   **2.缺点：**

​       每次调用select，都需要吧fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大；

​       同时每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那么这个开销也很大；

​        为了减少数据拷贝带来的性能循环，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变（限制为1024）。



- #### poll机制

   1.poll的机制和select类似，管理多个描述符也是进行轮询，根据描述符的状态进行处理。

   2.但是**poll没有最大文件描述符数量的限制**，poll改变了文件描述几个的描述方式，使用的了pollfd

结构而不是fd_set结构，使得poll支持的文件描述集合限制远远大于select的1024

- ####  epoll机制

  **1.基本原理：**epoll支持水平触发和边沿触发。最大的特点在于边缘触发，他只告诉进程哪些fd刚刚变为就绪状态，并且只通知一次。

     还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

  2.优点：

  - epoll没有描述符的个数限制**，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需要一次。**
  - 是Linux下多路复用IO接口 select/poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的CPU利用率，原因就是获取事件的时候，他无需遍历整个被侦听的描述符集，**只要遍历那些被内核IO事件异步唤醒二加入Ready队列的描述符集合。**

  ### 4.异步IO

  ​     同步IO中，在调用recvfrom方法时，及时kernel已经准备好了数据，也不会立即返回，必须再耗费一定的时间，将数据熊kernel完全拷贝到buf中后，recvfrom方法才会返回。

  

  ​    异步IO则有很大的不同：

  ​       1.用户调用一次请求数据的方法，该方法会无阻塞的立即返回。

  ​       2.OS接到请求后，会将用户所请求的数据从kernel拷贝到指定的位置。

  ​       3.数据拷贝完之后，第一步中注册的回调方法会被调用（或者出发一个信号，总之就是要让用户感知到数据已经拷贝完成）。

  ​       4.用户感知到这一事件，此时数据已经准备好，可以直接处理数据。 

  

